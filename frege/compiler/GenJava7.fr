{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011 - 2015, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
    Java code generation for the frege compiler

    This version of code generation tries to minimize boxing/wrapping of values.
    
    This is achieved through the following principles:
    - every frege type is mapped to a java
      type that extends @Lambda@ (for function types) or @Algebraic@
      for algebraic types. @Lambda@ and @Algebraic@ are abstract classes that
      both implement the @Lazy@ interface. Hence every non native value is
      a Lazy value.
    - Lazy arguments of functions or data constructors have type @Lazy@ if
      the type checker tells us that only non native values can be passed.
      Otherwise, the type is just @Object@. In effect, this means we can pass
      *anything* to the function - a primitive value (that gets autoboxed by java),
      a frege value or a closure.
    - The same holds for lazy fields of data constructors, so that native values can  
      remain unboxed all the time.
    - But a not yet evaluated value of function application or a lazy field must never
      be passed when a strict value is expected.  
 -}


package frege.compiler.GenJava7 where


import frege.Prelude hiding(apply, <+>)
import Data.TreeMap as TM(TreeMap, values, keys, each, insert, lookup)
import Data.List as DL(sortBy, partitioned)
import Data.Bits(BitSet, BitSet.member)
import Data.Graph (stronglyConnectedComponents tsort)

import  Compiler.enums.Flags as Compilerflags(TRACEG, COMMENTS)
import  Compiler.enums.RFlag
import  Compiler.enums.Visibility
import  Compiler.enums.Literals
import  Compiler.enums.CaseKind
import  Compiler.enums.TokenID(QUALIFIER)

import  Compiler.types.Kinds
import  Compiler.types.Positions
import  Compiler.types.Strictness
import  Compiler.types.JNames
import  Compiler.types.JTypes
import  Compiler.types.Packs
import  Compiler.types.QNames
import  Compiler.types.Types
import  Compiler.types.Tokens
import  Compiler.types.Patterns
import  Compiler.types.Expression
import  Compiler.types.ConstructorField
import  Compiler.types.Symbols
import  Compiler.types.Global as G

import  Compiler.common.Mangle
import  Compiler.common.Binders
import  Compiler.common.Annotate
import  Compiler.common.Types as TH(tauRho)
import  Compiler.common.Errors as E()

import  Compiler.classes.Nice

import  Compiler.instances.Nicer

import frege.compiler.Utilities     as U() 
import frege.lib.PP hiding(group, break, line)

import frege.compiler.Transform     as T(patternStrictness, patternRefutable)
import frege.compiler.tc.Util        as TC(sameTau, impliesG)
import frege.compiler.Typecheck     as TY(mainSigma, tc, tauString)
import frege.compiler.tc.Methods (NIKind, niKind)


import frege.compiler.gen.Match     as GM
import frege.compiler.gen.Util      as GU 
import frege.compiler.gen.Const     as GC
import frege.compiler.gen.Bindings  as GB

infixr 6 `<>`

--- Post condition of the code generation pass, always true
post = stio true


--- the main class name for this package
mainClass :: Global -> JName
mainClass g = if jn.base  `elem` javaLangNames then jn else jn.{qual=""}
    where jn = g.packClass g.thisPack



 
-- --- prefix for wrapper methods is ﬂ
-- flLigatur = "ﬂ"
-- --- prefix for method handles is ﬁ
-- fiLigatur = "ﬁ"

--- latin ƒ is prefix for class methods and postfix for Lambdas 
latinF    = "ƒ"
 
{--
     create a lazy method for the given symbol
 -}
lazyMethod :: Symbol -> StG JDecl
lazyMethod symv | symv.{flds?} || symv.{rkind?} = do
        g <- getST
        si <- symInfo symv
        let jname  = JX.static (workerMethod g symv)
            arity = if symv.{depth?} then symv.depth else length symv.flds
            isnative = symv.{nativ?} && isJust symv.nativ
         -- E.logmsg TRACEG sym.pos (text ("lazyMethod: " ++ nicer sym g ++ " :: " ++ nicer sym.typ g))
            sym = if isnative 
                 then symv.{typ <- objectifySigma}
                 else symv
         -- E.logmsg TRACEG sym.pos (text ("lazyMethod: " ++ nicer sym g ++ " :: " ++ nicer sym.typ g))
        let sigmas        = snd (U.returnTypeN arity sym.typ.rho)
            (rtau, _)     = U.returnType sym.typ.rho
            -- jrty            = rhoJT g rty
        let argdefs = evalArgDef attrFinal sigmas (take arity argNames)
            wcode   = if wrapped g sym
                    then wrapCode g JReturn rtau sym (map (instArg g) argdefs)
                    else if isnative
                         then let bind = nativeCall g sym (map (instArg g) argdefs)
                              in [JReturn bind.jex]
                         else []
 
         -- special support for native functions, call directly into native code
        let haswrapper  = arity > 0 && wrapped g sym || (not (null sym.typ.bound))
         
         -- be sure to pass ctx1, ctx2, ....
        let ctxs = map JAtom (take (length sym.typ.rho.context) ctxNames)
 
        let args        = argdefs
            rkind       = if sym.{rkind?} then sym.rkind else BitSet.singleton RValue
            jtype       = autoboxed (returnType rkind si.returnJT)                 
            
            abinds
                 | S ss <- sym.strsig = zipWith (adaptArg g) argdefs (ss ++ allLazy)
                 | otherwise          = zipWith (adaptArg g) argdefs allLazy
 
            call = newBind g si.retSig (JX.invoke (ctxs ++ map Binding.jex abinds) jname)
            callex = (adapt call.{jtype = si.returnJT} jtype).jex
            body = JBlock $
                        -- [ sComment (show b) | b <- abinds ] ++ 
                        [JReturn  callex]
            rBody = if haswrapper then body -- JBlock [JReturn callWrapper]
                     else JBlock wcode 
            -- bx jex = (toMode g rm (Bind {mode = rm,
            --                              ftype = ForAll [] rty,
            --                              jtype = jtype, jex})).jex
            result = JMethod { attr = attrs [JFinal, JPublic],
                             gargs = targs sym.typ,
                             name = "eval",
                             jtype, args = reverse args,
                             body = if isnative then rBody else body }
        stio result
         
lazyMethod sym = error "lazyMeth: no SymV"
  
{-- 
     Replace type variables with kind @KGen@
     that are the type of some argument (and hence stand for unknown native values)
     with the type for @java.lang.Object@, see 'PreludeBase.Object'
     -} 
objectifySigma :: Sigma -> Sigma
objectifySigma sig = ForAll nbound nrho
    where
        tree = findAnonRho TreeMap.empty [] sig.rho
        nbound = filter (isNothing . tree.lookup . fst) sig.bound
        nrho = U.substRho tree sig.rho
 
--- Find arguments whose type is a simple type variable of type KGen
findAnonSigma :: TreeMap String Tau -> [String] -> SigmaT β -> TreeMap String Tau
findAnonSigma acc except (ForAll bound rho) = findAnonRho acc (except ++ map fst bound) rho
findAnonRho acc except RhoTau{tau=TVar{kind=KGen,var=n}} 
     | n `elem` except = acc
     | otherwise       = insert n  (TY.tc "Object") acc
findAnonRho acc except RhoFun{sigma, rho}
     = findAnonRho (findAnonSigma acc except sigma) except rho 
findAnonRho acc _ _ = acc

--- tells how many lazy functions go into one Lambda class.
--- *Important* This must be a power of 2!
fpC = 256

{--
     Prepare a function for lazy usage.
     
     For every top level function, including native ones, there may be a
     Lambda object that one can pass to other functions if the need arises.
     
     The eval method of that object will invoke the actual function code.
     
     We generate a
     > final static public class extName extends FunN<X> {
     >     public extName() {}
     >     final public static extName it = new extName();
     >     final public X eval(....) { ... }
     >  } 
     for unconstrained functions and
     > final static public class extName extends FunN<X> {
     >     final Constraint ctx$1;
     >     final COnstraint ctx$1;
     >     public extName(Constraint ctx$1, Constraint ctx$2) { ... }
     >     final public X eval(....) { ... }
     >  }
     for constrained ones. 
     -}
lazyDecl sym jname
    | SymV {name, depth, typ} <- sym, not name.isLocal = prep name depth         typ
    | SymD {name, typ} <- sym                          = prep name (U.arity sym) typ
    | otherwise = do
        g <- getST
        E.fatal sym.pos (text("lazyDecl: " ++ nicer sym g)) 
    where 
      prep :: QName -> Int -> Sigma -> StG JDecl
      prep name depth typ = do
        g    <- getST
        -- si   <- symInfo sym
        eval <- lazyMethod sym
        let funXtyp   = jtFunc depth (eval.jtype)
            className = JName.base jname
            classTyp  = Nativ{typ=className, typeargs=[]}
            constraints = zipWith (makeConstraintDef g)  sym.typ.rho.context ctxNames
            constrargs  = zipWith (makeConstraintArg g)  sym.typ.rho.context argNames
            constructor = JConstr {attr = attrs [JPublic],
                                 jtype = classTyp,  
                                 args = constrargs,
                                 body = JBlock (take (length constraints)
                                                 (zipWith JAssign
                                                     (map JAtom ctxNames)
                                                     (map JAtom argNames)))}
            it0 = JMember {attr = attrTop,
                            jtype = classTyp,
                            name = "inst",
                            init = Just (JNew{jt = classTyp, args=[]})}
            itc = JMethod {
                        attr = attrTop, gargs = [],
                        jtype = classTyp,
                        name = "inst",
                        args = constrargs,
                        body = JBlock [JReturn inst]}
            inst = JNew{jt = classTyp, args = take (length constrargs) (map JAtom argNames)}
            result = JClass{attr = attrTop, 
                        jtype = classTyp, 
                        extend = Just funXtyp, 
                        implement = [], 
                        defs = constraints ++ [constructor, eval,
                                if null constrargs then it0 else itc]}
        return result
            
            
{--
     Construct a java name for a variable/method that
     holds or returns the lambda class for a given symbol.
     
     The names live in the _Consts_ subclass and are either
     static members (for function without constraints) or
     static methods that take the constraints for instantiation.
     
     The method/member name is the last part of the java name with an appended 
     latin "ƒ" followed by the hash code of the qname for disambiguation of multiple
     symbols with the same name.
     
     Hence with:
     
     > import some.Package as P()
     > data T = ... where
     >      foo = ...
     >
     > foo = 
     > bar = [foo, T.foo, P.foo]
     
     this would result in 3 different names of the form
     
     >  fooƒ1234
 -}
extFname :: Global -> Symbol -> JName
extFname g sym = mg (mangled sym.name.base ++ latinF ++ String.format "%x" (hashCode sym.name))
     where -- qname = Symbol.name sym
           -- worker = workerMethod g sym
           mg = memberOf (JName "" (constClass g))
 
-- -- pure native hashCode :: String -> Int
 
{--
     Require that there be an instance of a Lambda suitable to call
     the symbol lazily at runtime and return a 'Binding' for that handle.
 -}
reqLam :: Symbol -> StG Binding
reqLam sym = do
         g <- getST
         let jname = extFname g sym
             bind jn = newBind g sym.typ (JX.static (memberOf jn "inst"))
         case g.gen.lambdas.lookup sym of
            Nothing -> do
                changeST Global.{gen <- GenSt.{lambdas <- insert sym Nothing}}
                return (bind jname)
            Just Nothing  -> return (bind jname)
            Just (Just j) -> return (bind j) 

--- like 'reqLam' but returns ()
--- In addition, it checks for CAFs and generates lambdas for functions only.
ensureLam sym
    | sym.depth > 0 = reqLam sym >> return ()
    | otherwise     = return () 
   
{--
     Generate the anonymous Lambdas for all symbols required with 'reqLam'
 -}
genAnonLams = do
        g <- getST
        
        let syms = [ sym | (sym, Nothing) <- each g.gen.lambdas ]
            jnames = map (extFname g) syms
        
        sequence (zipWith lazyDecl syms jnames)

reconstruct ∷ [Token] → StIO ()
reconstruct [] = return ()
reconstruct (x:xs)
    | not (null x.qual) = reconstruct (x.qual ++ (x.{qual=[]} : xs))
reconstruct [x] = U.println (tval x) >> U.println ""
reconstruct (a:b:xs) = do
    U.print (tval a)
    unless (a.vor b) do
        if (a.line != b.line) then U.println "" else U.print " "
    reconstruct (b:xs)

tval ∷ Token → String
tval Token{tokid, value}  = case tokid  of
    TokenID.QUALIFIER → value ++ "."
    _ → value

 
pass :: StIO (String, Int)
pass = do
    liftStG setupLambdas
    -- changeST Global.{unique <- (*100000) . succ . (`quot` 100000)}
    g <- getSTT
    let modul = JClass{attr=attrs [JFinal, JPublic], 
                    jtype = Ref{jname = JName{qual="", base=(mainClass g).base}, typeargs=[]}, 
                    extend = fmap (sigmaJT g) g.options.extends, 
                    implement = map (sigmaJT g) g.options.implements, 
                    defs=[]}
        headline = (PP.pretty 200 (anno modul)).replaceAll ´}´ ""
    -- U.print "final public class "
    -- U.print (mainClass g).base
    U.println headline
    reconstruct (g.options.code)

    let vals = values g.thisTab
        cClass = JMember {
            attr = attrTop,
            jtype = cType,
            name = ijLigatur, -- println ("final public static " ++ constClass g ++ "
            init = Just (JNew cType []) }
        cType = Ref (JName "" (constClass g)) []
    pp (anno cClass)
 
    liftStG (mapSt (symCode TreeMap.empty) (sortBy (comparing Symbol.name) [ s | s@SymT {sid} <- vals ]))
        >>= ppSSC
    liftStG (mapSt (symCode TreeMap.empty) (sortBy (comparing Symbol.name) [ s | s@SymC {sid} <- vals ]))
        >>= ppSSC
    liftStG (mapSt (symCode TreeMap.empty) (sortBy (comparing Symbol.name) [ s | s@SymI {sid} <- vals ]))
        >>= ppSSC
    -- do variables in dependency order, this is so that CAFs refer only to CAFs
    -- whose java initialization occurs earlier
    let vars = [ s | s@SymV {} <- vals ]
    -- names   <- mapSt U.fundep vars
    -- varsyms <- mapSt U.findV (concat (U.tsort names))
    liftStG (
            mapSt U.fundep vars 
            >>= mapSt U.findV . concat . tsort 
            >>= mapSt (symCode TreeMap.empty))
        >>= ppSSC 
    -- mapSt (symCode Tree.empty) varsyms >>= ppSS

    -- constants
    liftStG reqMain                 -- make sure main class is made
    makeConstants
 
    -- lazy lambda classes
    g <- getSTT 

    let toMaybe = [
            "final public static TMaybe _toMaybe(Object it) {",
            "   return it == null ? TMaybe.DNothing.it : TMaybe.DJust.mk(it);",
            "}",
            ]
    when (g.thisPack == pPreludeBase) (forM_ toMaybe U.println)
    let toList = [ 
             "final public static<T> TList _toList(T[] arr) {",
             "   if (arr == null) return PreludeBase.TList.DList.it;",
             "   int i = arr.length - 1;",
             "   TList it = TList.DList.it;",
             "   while (i >= 0) {",
             "       final T elem = arr[i];",
             "       i = i-1;",
             "       if (elem == null) continue;",
             "       it = TList.DCons.mk(elem, it);",
             "   }",
             "   return it;",
             "}",
             "final public static TList _toList(Iterable<Object> iter) {",
             "   return (new frege.runtime.Fun1<TList>() {",
             "       @Override public TList eval(Object arg) {",
             "           @SuppressWarnings(\"unchecked\")",
             "           final java.util.Iterator<Object> iter = (java.util.Iterator<Object>)arg;",
             "           while (true) {",
             "               if (iter.hasNext()) {",
             "                   final Object x = iter.next();",
             "                   if (x == null) continue;",
             "                   return PreludeBase.TList.DCons.mk(x,", 
             "                              this.apply(iter));",
             "               }",
             "               else return PreludeBase.TList.DList.it;",
             "           }",
             "       }",
             "   }).apply(iter.iterator()).<TList>forced();",
             "}" ]                
 
    when (g.thisPack == pPreludeBase) (forM_ toList U.println)
    case haveMain g of
        Just sym -> forM_ (mainCode g sym) U.println
        Nothing  -> return ()
    U.println "}"
 
    return ("java7 class", 1)
 
--- print lists of lists of annotatable items
ppSS xss = forM_ (concat xss) (pp • anno)

unCommentG g gs = if Compilerflags.isOn (Global.options g).flags COMMENTS 
                    then gs else unComment gs

ppSSC xss = do
    g <- getSTT
    ppSS (map (unCommentG g)  xss)

--- the java code to run the main function
mainCode g sym
    | sym.depth == 0 = [    -- code for CAF main
        "public static void main(final java.lang.String[] argv) {",
        "  final long t1 = java.lang.System.nanoTime();",
        "  java.lang.Integer xit = frege.runtime.Runtime.runMain(",
        "    " ++ g.unpack pPreludeBase ++ ".TST.performUnsafe(",
        "      " ++ "frege.runtime.Delayed.<frege.runtime.Lambda>forced(",
        "        " ++ show (mainClass g `memberOf` "_main") ++ ")));",
        "  final long t2 = java.lang.System.nanoTime();",
        "  frege.runtime.Runtime.stderr.get().println(",
        "    \"runtime \" + ((((t2 - t1) + 500000) / 1000000) / 1e3) + \" wallclock seconds.\");",
        "  if (xit != null) java.lang.System.exit(xit);",
        "}"
        ]
    | otherwise = [     -- code for function main
        "public static void main(final java.lang.String[] argv) {",
        "  final long t1 = java.lang.System.nanoTime();",
        "  java.lang.Integer xit = frege.runtime.Runtime.runMain(",
        "    " ++ g.unpack pPreludeBase ++ ".TST.performUnsafe(",
        "      " ++ show (extFname g sym) ++ ".inst.apply(" 
                    ++ g.unpack pPreludeBase 
                    ++ "._toList(argv)).<frege.runtime.Lambda>forced()));",
        "  final long t2 = java.lang.System.nanoTime();",
        "  frege.runtime.Runtime.stderr.get().println(",
        "    \"runtime \" + ((((t2 - t1) + 500000) / 1000000) / 1e3) + \" wallclock seconds.\");",
        "  if (xit != null) java.lang.System.exit(xit);",
        "}"
        ]
    
--- tell if there is a main function in this module
-- haveMain :: Global -> Bool
haveMain g = case Global.findit g (VName g.thisPack "main") of
        Just sym | sym.name.pack == g.thisPack = Just sym
        other = Nothing

reqMain = getST >>= maybe (return ()) ensureLam . haveMain 
    

makeConstants = do
         g <- getSTT
         lams   <- liftStG $ genAnonLams 
         consts <- liftStG $ mapSt genConst (keys g.gen.consts)
         let ccType = (Ref (JName "" (constClass g)) [])
             constclass = JClass   { attr = attrs [JPublic, JStatic],
                                     jtype = ccType,
                                     extend = Nothing,
                                     implement = [],
                                     defs = constructor:consts ++ lams}
             constructor = JConstr { attr = attrs [JPublic],
                                     jtype = ccType,
                                     args = [],
                                     body = JBlock []}
             lsyms  = [ sym | (sym, Nothing) <- each g.gen.lambdas, Symbol.vis sym != Private ]
             qnames = map Symbol.name lsyms
             jnames = map (JName.base . extFname g) lsyms
         pp  (annotation "FunctionPointers" [
                ("qnames", anno qnames),
                ("jnames", anno jnames),
            ])                                     
         pp (anno constclass)
         changeSTT Global.{sub <- _.{funPointers <- insert g.thisPack (zip qnames jnames)}} 
         return ()
     where
         
         genConst (kind,value) = do
             g <- getST
             jname <- findConst Lit {pos=Position.null, typ = Nothing, kind, value}
             let lsigma = TY.litSigma kind
                 numv = value.replaceAll ´_´ ""
                 bjt  = sigmaJT g lsigma
             let it = JMember { attr = attrs [JPublic, JFinal],
                                jtype = bjt, name = jname.base, init = Just ex }
                 ex = case kind of
                     LBig   -> JNew (Ref (JName "" "java.math.BigInteger") []) [JAtom (show numv)]
                     LRegex -> JInvoke
                                 (JStMem (JName "java.util.regex.Pattern" "compile") [])
                                 [JAtom value, JAtom (show flags)] where
                                    flags = Regex.unicode_character_class +
                                            Regex.unicode_case +
                                            Regex.canon_eq
                     LInt      -> JAtom numv
                     LLong     -> JAtom numv
                     LDouble   -> JAtom numv
                     LFloat    -> JAtom numv
                     otherwise -> JAtom value
 
                 -- nb = newBind g lsigma ex
             stio it
 
 
-- genMain = do
--     g <- getST
--     case (VName g.thisPack "main").findit g of
--         Just sym | sym.name.pack == g.thisPack = do         -- we have a main
--             let -- tc n = TCon {pos=sym.pos, name = TName pPreludeBase n}
--                 tauSig tau = ForAll [] (RhoTau [] tau)
--                 sarr = TName (Pack.new "frege.prelude.Arrays") "StringArray"
--                 sarrTau = tauSig (TApp (TCon Position.null sarr) (tc "Immutable"))
--             sarrJT <- sigmaJT sarrTau
--             let args = [(attrFinal, sarrTau, strict sarrJT, "argv")]
--             let st   = (tc "ST").name
--                 stpu = MName st "performUnsafe"
--                 toli = MName sarr "toList"
--             vstpu <- U.findV stpu
--             vtoli <- U.findV toli
--             let avb = argBind (head args)
--                 slist = TApp (tc "[]") tauString
--                 sig1 = ForAll [] (RhoFun [] (sarrTau) (RhoTau [] slist))
--             btoli <- instSymDirect sym.pos vtoli sig1
--             let  apparg = JInvoke btoli.jex [avb.jex]
--             bmain <- instSymDirect sym.pos sym mainSigma
--             let applist = (JCast jtFun
--                             • JX.invoke [] • JX.xmem "_e"
--                             • JX.invoke [apparg]) bmain.jex
--                 iovoid = TApp (TApp (tc "ST") (tc "RealWorld")) (tc "()")
--                 sig2 = ForAll [] (RhoFun [] (tauSig iovoid) (RhoTau [] (tc "()")))
--             bperf <- instSymDirect sym.pos vstpu sig2
--             let appio = {- JCast jtFun -} (JInvoke bperf.jex [applist])
--                 -- appe  = JInvoke (JExMem appio "_e") []
--                 appe  = JInvoke (JStMem (JName "frege.RT" "fjMain") []) [appio]
--                 gettime s = JMember {attr = attrFinal, jtype = Nativ "long" [], name=s,
--                             init = Just (JInvoke
--                                 (JStMem (JName "java.lang.System" "nanoTime") [])
--                                 [])}
--                 stmts = [ JLocal (gettime "t1"), JEx appe, JLocal (gettime "t2"), times ]
--                 times = JEx (JInvoke (JStMem (JName "java.lang.System.err" "println") [])
--                                 [ex1])
--                 ex1 = JBin (JAtom "\"runtime \"") "+" ex2
--                 ex2 = JBin ex3 "+" (JAtom "\" wallclock seconds.\"")
--                 ex3 = JBin ex4 "/" (JAtom "1e3")
--                 ex4 = JBin ex5 "/" (JAtom "1000000")
--                 ex5 = JBin ex6 "+" (JAtom "500000")
--                 ex6 = JBin (JAtom "t2") "-" (JAtom "t1")
--                 mMeth = JMethod {attr = attrs [JPublic, JStatic], gargs = [],
--                             jtype = Nativ "void" [],        -- sure thing :)
--                             name  = "main",
--                             args, body = JBlock stmts }
--             stio [mMeth]
--         sonst -> stio []
-- 
--- the @constructor@ method
--- >final public int _constructor() { return n; }
cMethod n = atomMethod "_constructor" (Nativ "int" []) (show n)
-- 
-- --- the @_u@ method
-- --- >final public boolean _u() { return false; }
-- uMethod = atomMethod "_u" (Nativ "boolean" []) "false"
-- 
-- --- the @_v@ method
-- --- >final public Lazy<FV> _v() { return this; }
-- vMethod = atomMethod "_v" (lazy jtValue) "this"
-- 
-- --- the @_e@ method
-- --- >final public FV _e() { return this; }
-- eMethod = atomMethod "_e" jtValue "this"
 
 
{--
  * [usage] @atomMethod name type atom@
  * [returns] a 'JMethod' of the form @final public /type/ /name/() { return /atom/; }@
  -}
atomMethod s jt atom = JMethod {attr = attrs [JFinal, JPublic], gargs=[], jtype = jt,
                     name = s, args=[], body = JBlock [ JReturn (JAtom atom) ]}
 
 
{--
   Code for data constructors
 
   - For nullary constructors, a subclass of @Value@ is derived that contains a singleton and
     an appropriate @mk@ method.
   - For non-strict constructors with arity > 0, a subclass of @Algebraic@
     with a static @mk@ method is derived.
   - For strict constructors, the members are generated directly.
  -}
conCode :: Symbol -> [Symbol] -> Symbol -> StG [JDecl]
conCode symt cons (sym@SymD {flds, cid}) = do
    g <- getST
    si <- symInfo sym
    -- lazyM <- lazyDeclarations [sym]
    let symtjt  = sigmaJT g (Symbol.typ symt)
        jtype   = (variantType g symtjt sym).{jname <- JName.{qual = ""}}
        -- argtys  = map ConField.typ flds
        arity   = length flds
        comment = JComment (nice sym g)
        result  = sumCon
        sumCon  = JClass {attr = attrTop,
                             jtype = jtype, 
                             extend = Just jtAlgebraic, 
                             implement = imp, defs}
        imp = [symtjt]
 
        defs = [comment, constr, cMethod cid, make]
                   ++ singlelazy ++ getters ++ members
        singlelazy 
            | arity == 0 = [JMember {attr = attrs [JFinal, JPublic, JStatic],
                                         jtype = jtype,
                                         name = "it",
                                         init = Just (JX.new [] jtype)}]
            | otherwise = []
        !make 
            | arity == 0 = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                                     gargs = [], jtype = symtjt, name = "mk",
                                     args = [],
                                     body = JBlock [JReturn (JAtom "it")]}   
            | otherwise  = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                                     gargs = [], jtype = symtjt, name = "mk",
                                     args = constrargs,
                                     body = JBlock [JReturn (JNew jtype args)]}
 
        
        constrargs  = argDefs attrFinal si argNames
        args = take arity (map JAtom argNames)
        
         -- rbinds = [ Bind RLazy sig jt (JAtom n) | (_,sig,jt,n) <- constrargs ]
        constr = JConstr {attr = attrs [JPrivate], jtype = jtype,
                             args = constrargs,
                             body = JBlock super}
        namedfields = namedFields flds
        !super 
            | arity == 0 = []
            | otherwise = zipWith (assign g) namedfields constrargs
                                                     
        getters = -- if symt.product then [] else
                     atomMethod (conGetter sym.name) jtype "this" :
                     [ atomMethod (conGetter (Symbol.name con))
                                  (variantType g symtjt con) "null"
                          | con <- cons, Symbol.sid con != sym.sid ]  -- other constructors
        members  =  zipWith mkMember namedfields constrargs
    stio [result]
conCode symt cons nocon = error "conCode: no Con"

mkMember  Field{pos, name = Just mem, doc, vis, strict=s, typ} (_,_,jt,_) 
            = JMember {attr = attrs [JFinal, JPublic],
                    jtype = jt,
                    name = mem, 
                    init = Nothing}
mkMember  f _ = error "mkMember: apply only named fields here"     -- see namedFields

assign :: Global -> ConField QName -> FormalArg -> JStmt
assign g Field{pos, name = Just toname, doc, vis, strict, typ} formalArg  
        = JAssign (JAtom toname) bind.jex
    where
        bind   = adaptArg g formalArg (if strict then S[] else U)
assign g f a = error "assign: apply only named fields here"     -- see namedFields


symCode binds sym = do
    g <- getST
    E.logmsg TRACEG sym.pos (text ("symbol code for " ++ nicer sym g))
    symCode' binds sym
    
{--
  * Code for data types
  *
  * - Native types create a class @TName@ that acts as namespace for
  *   member definitions.
  * - Enumerations create a class @TName@ that contains final Box.Int DCon = Box.Int.mk(cid)
  * - Algebraic types create an interface @TName@ that extends @Val@
  *   implements @Lazy<FV>@ and contains
  *   an abstract method @DCon@ to get the variant associated with @DCon@.
  -}
symCode' binds (sym@SymT {enum=true}) = do
     g <- getST
     let vals  = sortBy (comparing Symbol.name) (values sym.env)
         cons  = [ con | con@SymD {sid} <- vals ]                    -- constructors
         other = [ sym | sym <- vals, not (Symbol.{flds?} sym)]      -- non constructors

     -- lazyDefs <- lazyDeclarations vals 
     subDefs <- mapSt (symCode binds) other
 
     let jtype = Ref {jname = U.javaName g sym.name, typeargs = []}     -- TName
         !result = JClass {attr = attrTop, jtype,
                         extend = Nothing,
                         implement = [],
                         defs = (constr : conDefs) ++ concat subDefs}
         constr = JConstr { attr = attrs [JPrivate], jtype, args=[], body = JBlock []}
         conDefs = [ JMember {attr = attrTop,
                         jtype = jtEnum,
                         name = mangled name.base,
                         init = Just (JX.atom (show cid))}
                       | SymD {name, cid} <- cons ]
     stio [JComment (nice sym g), result]
 
 
symCode' binds (sym@SymT {product=true, newt=true}) = do
     g <- getST
 
     let vals = sortBy (comparing Symbol.name) (values sym.env)
         other = [ sym | sym <- vals, not (Symbol.{flds?} sym)]      -- sub definitions
 
     -- lazyDefs <- lazyDeclarations other
     subDefs <- mapSt (symCode binds) other
 
     let jtype  = Ref (U.javaName g sym.name) []
         defs   = concat subDefs
         !result = JClass {attr = attrs [JAbstract, JPublic, JStatic], jtype,
                          extend = Nothing, implement = [], defs}
     stio [JComment (nice sym g), result]
 
 
symCode' binds (sym@SymT {product=true}) = do                    -- product
    g <- getST
 
    let vals    = sortBy (comparing Symbol.name) (values sym.env)
        other   = [ sym | sym <- vals, not (Symbol.{flds?} sym)]
    subDefs     <- mapSt (symCode binds) other
    -- lazyDefs    <- lazyDeclarations vals
    
    let symjt   = sigmaJT g sym.typ
        jtype   = symjt.{jname = U.javaName g sym.name}
        symd    = head [ con | con@SymD {sid} <- vals ]            -- constructor
    si <- symInfo symd
    let -- (_, argtys) = U.returnType symd.typ.rho
        -- struct      = symd.strsig.isStrict
        -- funty   = sigmaJT g symd.typ
        -- ftypes  = map (sigmaJT g) (map ConField.typ symd.flds)        -- field types
        -- argjts  = map (sigmaJT g) argtys
        arity   = length symd.flds
        imp     = []                              -- implements Value
        defs    = [comment, constr, cMethod symd.cid,
                         -- atomMethod "_v" jtype "this",
                         -- atomMethod "_e" jtype "this",
                         make] ++ members  ++ concat subDefs
        comment     = JComment (nice symd g)
        constrargs  = argDefs attrFinal si argNames
        args        = take arity (map JAtom argNames)
        constr      = JConstr {attr = attrs [JPrivate], jtype = jtype,
                             args = constrargs,
                             body = JBlock super}
        namedfields = namedFields symd.flds
        super = zipWith (assign g) namedfields constrargs
        make  = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                         gargs = jtype.typeargs, jtype, name = "mk",
                         args = constrargs,
                         body = JBlock [JReturn (JNew jtype args)]}
        members = zipWith mkMember namedfields constrargs
        !result = JClass {attr = attrTop, jtype,
                          extend = Just jtAlgebraic, 
                          implement = imp, defs}
    stio [JComment (nice sym g), result]

symCode' binds (sym@SymT{env, nativ = Nothing, product=false, enum=false, newt=false}) | null env
        = do
            g <- getST
            stio [JComment (nice sym g)]                          -- empty type
        
symCode' binds (sym@SymT {nativ=Nothing}) = do                   -- sum type
     g <- getST
     let vals = sortBy (comparing Symbol.name) (values sym.env)
         cons = [ con | con@SymD {sid} <- vals ]
         funs = [ sym | sym@SymV {sid} <- vals, not (Symbol.{flds?} sym)]
     funDefs <- mapSt (symCode binds) funs
     -- lazyFuns <- lazyDeclarations funs
     conDefs <- mapSt (conCode sym cons) cons
     let symjt = sigmaJT g sym.typ
     -- E.logmsg TRACEG sym.pos (text ("symCode: " ++ nicer sym g ++ " " ++ show symjt))
     let jtype
            | symjt.{jname?} = symjt.{jname = U.javaName g sym.name}
            | otherwise = Ref (JName "" "Strange") [symjt]
         getCons = [JMethod {attr = attrs [JPublic], gargs=[],
                             jtype = variantType g jtype con,
                             name = conGetter (Symbol.name con),
                             args = [], body = JEmpty}
             | con <- cons ]
         mClass | null funs = []
                | otherwise    = [JClass {attr = attrs [JPublic, JStatic, JFinal],
                                     jtype = Ref (JName "" "M") [],
                                     extend = Nothing, implement = [],
                                     defs = concat funDefs}]
         result = JInterface {attr = attrs [JPublic], jtype,
                             implement = [jtValue, Lazy Lambda],
                             defs = getCons ++ concat conDefs ++ mClass}
     stio [JComment (nice sym g), result]
 
symCode' binds (sym@SymT {sid, nativ = Just _}) = do                               -- nativ
     g <- getST
     let vals = sortBy (comparing Symbol.name) (values sym.env)
     subDefs <- mapSt (symCode binds) vals
     -- lazyDefs <- lazyDeclarations vals
     let jtype  = Ref {jname = U.javaName g sym.name, typeargs=[]}
         result 
            | null subDefs = JComment "no local functions for this type"
            | otherwise = JClass {attr = attrTop,
                             jtype, extend = Nothing, implement = [],
                             defs = concat subDefs}
     stio [JComment (nice sym g), result]
 
{--
    Code for type classes
  
    - interface @Cname@</a/> where /a/ is the class variable
    - for each class method, an abstract method that returns a function (i.e. @Lambda@)
    - name space @I@ for default function implementations
    -}
symCode' binds (sym@SymC {sid}) = do           -- type class
     g <- getST
     let vals = sortBy (comparing Symbol.name) (values sym.env)
     abstrFuns <- mapSt (abstractFun sym) vals
     -- let ivals = filter (isJust • Symbol.expr) (filter Symbol.{expr?} vals) -- default implementations
     -- implFuns <- mapSt (symCode binds) ivals
     -- taujt    <- tauJT sym.tau
     let jtype = Ref (U.javaName g sym.name) []
         superclasses = [ Ref (U.javaName g nm) [] | nm <- sym.supers ]
         -- implDef
         --     | null implFuns = []
         --     | otherwise = [JClass {attr = attrs [JPublic, JStatic],
         --                     jtype = Ref (JName "" "I") [],
         --                     extend = Nothing, implement = [], defs = concat implFuns}]
         result = JInterface (attrs [JPublic]) jtype superclasses
                            (concat abstrFuns) 
                            -- (concat abstrFuns ++ implDef)
     stio [JComment (nice sym g), result]
 
{--
     Code for instances
 
     - interface @Cname@</a/> where /a/ is the class variable
     - for each class method, an abstract method that returns a function
     - name space for default functions (?)
     -}
symCode' binds (sym@SymI {sid}) = do             -- instance definition
     g <- getST
     csym <- U.findC sym.clas
 
     let -- bnds    = sym.typ.bound
         classes = sym.clas:csym.supers
         -- the functions we must provide in the instance
         superMethods = [ m.name.base | c <- classes,
                                   SymC{env} <- g.findit c,
                                   m@SymV{}  <- values env ]
         -- links in type that point to instance members of this class and its superclasses
         -- The goal is to have (links to) implementations of all super class methods. 
         methods2 = case instTSym (Symbol.typ sym) g of
              Just (tsym@SymT {pos}) -> [ alias |
                                SymL {name, alias} <- values tsym.env, alias.{tynm?},    -- links
                                alias `notElem` methods1,                 -- avoid duplicates
                                alias.base `elem` superMethods,           -- mentioning one of our methods
                                name.base `notElem` map QName.base methods1,
                                SymI {clas} <- g.findit alias.tynm, -- pointing to an instance
                                SymC {supers} <- g.findit clas,     -- of a class that is in our hierarchy
                                clas `elem` classes || any (`elem` classes) supers]
              _ -> error "unexpexted result from instTSym"
         methods1 = map Symbol.name (values sym.env)
         -- methods of super classes that are implemented in the type itself
         methods3 = case instTSym (Symbol.typ sym) g of
            Just (tsym@SymT {pos}) -> [ sym.name |
                                 sym  <- values tsym.env,
                                 sym.name.base `elem` superMethods,
                                 sym.name.base `notElem` methods] where
                        methods = map QName.base (methods1++methods2)
            _ -> error "unexpexted result from instTSym" 
         methods  = methods1 ++ methods2 ++ methods3
 
     let vals = sortBy (comparing Symbol.name) (values sym.env)
 
     instFuns  <- mapSt (instFun csym sym) methods
     instImpls <- mapSt (symCode binds) vals
     -- lazyImpls <- lazyDeclarations vals
     -- let symjt    = sigmaJT g sym.typ
     let constraints = zipWith (makeConstraintDef g)  sym.typ.rho.context ctxNames
         constrargs  = zipWith (makeConstraintArg g)  sym.typ.rho.context argNames
 
 
     let jtype = Ref (U.javaName g sym.name) []          -- jtargs
         etype = Ref (U.javaName g sym.clas) []          -- [instjt]
         constructor = JConstr {attr = attrs [JPublic],
                                 jtype = jtype,  
                                 args = constrargs,
                                 body = JBlock (take (length constraints)
                                                 (zipWith JAssign
                                                     (map JAtom ctxNames)
                                                     (map JAtom argNames)))}

         singleton
            | null constrargs = [JMember{attr = attrTop, jtype, name="it", 
                init = Just (JNew jtype [])}]
            | otherwise = [] 
         result = JClass {attr = attrs [JPublic, JFinal, JStatic], jtype,
                          extend = Nothing,
                          implement = [etype],
                          defs = (constructor : constraints)
                             ++ singleton
                             ++ concat instFuns
                             ++ concat instImpls}
     stio [JComment (nice sym g ++ " :: " ++ nice sym.typ g), result]
 
 
symCode' _ (sym@SymL{}) = getST >>= stio • (:[]) • JComment • nice sym
symCode' binds (sym@SymV {nativ = Just item}) = methClass sym
symCode' binds (sym@SymV {expr = Just x})
    | sym.depth > 0 = do
        g <- getST
        trace g
        funCode sym binds
    | otherwise     = do
        g <- getST 
        trace g
        cafCode sym binds
    where
        trace g = E.logmsg TRACEG sym.pos (text ("compiling " ++ sym.nice g))
 
--- unimplemented items produce a comment and an error message
symCode' binds sym = do
     g <- getST
     E.error sym.pos (text ("Can't generate code for " ++ nice sym g))
     stio [JComment (nice sym g)]
 
--- declare abstract class Member function
abstractFun symc (sym@SymV {sid}) = do
     g <- getST
     si <- symInfo sym
     let !classCtx = Ctx {pos=Position.null, 
                        cname = Symbol.name symc, 
                        tau = Symbol.tau symc }
         !ctxs = filter (not . TC.sameCtx classCtx) sym.typ.rho.context
                     
 
     let constrformal = zipWith (makeConstraintArg g)  ctxs  ctxNames
         !cafMeth = sym.depth == 0
     let !result = JMethod {attr = attrs [JPublic],
                             gargs = [],       -- map targ (filter (!=tauvar) bnds),
                             jtype = if cafMeth 
                                        then lazy si.returnJT 
                                        else jtFunc sym.depth (lazy si.returnJT),    
                             name = latinF ++ mangled sym.name.base,
                             args = constrformal,
                             body = JEmpty}
     stio [JComment ((nice sym g) ++ " :: " ++ nice sym.typ g), result]
abstractFun symc syml | SymL {alias} <- syml = do
    g <- getST
    sym <- U.findV alias
    let classCtx = Ctx {pos=Position.null, 
                        cname = Symbol.name symc, 
                        tau = Symbol.tau symc }
        ourCtx = [ ctx | ctx <- sym.typ.rho.context, ctx.cname == classCtx.cname ]
    case ourCtx of
        [it] | it.tau.var == classCtx.tau.var =
                abstractFun symc sym.{name <- QName.{base = syml.name.base}}
             | otherwise = do
                -- we have C a => ...
                -- but we need C c
                -- so first rename all c to a new name
                -- then rename a to c
                let nn = head [ nn | nn <- allBinders g,
                                     nn != classCtx.tau.var,
                                     nn `notElem` sym.typ.vars ]
                    tv = classCtx.tau.{var=nn}
                    s1 = U.substSigma (TM.singleton classCtx.tau.var tv) sym.typ
                    s2 = U.substSigma (TM.singleton it.tau.var classCtx.tau) s1
                abstractFun symc sym.{typ=s2, name <- QName.{base = syml.name.base}}
        [] -> E.fatal syml.pos (text ("aliased abstract function misses "
                                        ++ nice symc g ++ " context:") </>
                                nest 4 (text (nice sym.name g ++ " :: " ++ nice sym.typ g)))
        _  -> E.fatal sym.pos (msgdoc ("aliased abstract function has more than one "
                    ++ nice symc g ++ " contexts "
                    ++ nice sym.name g ++ " :: " ++ nice sym.typ g))
         
abstractFun symc symx = do
    g <- getST
    E.fatal symx.pos (msgdoc ("Can't abstractFun " ++ nice symx g ++ " of " ++ nice symc g))
 
{--
   >  class @Eq eq@
   >  instance `Eq_(,,,)` :: forall u v w x.(Eq v,Eq w,Eq x,Eq u) => (w,x,u,v)
   >  class member function `Eq.!=` :: forall eq.Eq eq => eq -> eq -> Bool
   >  instance member `Eq_(,,,).!=` :: forall a b c d.(Eq b,Eq c,Eq d,Eq a) => (c,d,a,b) -> (c,d,a,b) -> Bool
   Extra type variables and constraints in instance member must be retained.
   Therefore:
   1. rename all type variables in instance member type so that the type variables
   in the instance type and the instance member type are distinct
   2. unify class member type and instance member type, note what is bound to the class variable
   3. unify instance type and the result from previous step
   4. substitute it in instance member type
   5. reconstruct forall bound in instance member type
  -}
fakeInstSigma (symc@SymC{supers}) (symi@SymI{sid}) sym | Symbol.{typ?} sym = do
     g <- getST
     let symjsb      = sym.typ.vars
         instjsb     = symi.typ.vars
 
     let 
        newvars = [ TVar {pos=sym.pos, var, kind=KVar} |
                         var <- allBinders g,
                         var `notElem` instjsb,
                         var `notElem` symjsb ]
        tree1 = TM.fromList (zip symjsb newvars)
        rho1  = U.substRho tree1 sym.typ.rho

     E.logmsg TRACEG sym.pos (text ("making fake type for  " ++ nicer sym g))        
     E.logmsg TRACEG sym.pos (text ("renamed  " ++ nicer sym.typ g ++ "  to  " ++ nicer rho1 g))
 
     let classes = symc.name:symc.supers
         -- clsm = head [ sym | c <- classes, sym <- (MName c sym.name.base).find g ]
         (memc,className) = head [ (sym,c) | c <- classes, sym <- g.findit (MName c sym.name.base) ]
     symc <- U.findC className
     let clas = symc.tau
         tree2 = U.unifySigma g memc.typ (ForAll [] rho1.{context=[]})
     E.logmsg TRACEG sym.pos (text ("unifySigma (" ++ nicer memc.typ g ++ ") "
             ++ "(" ++ nicer (ForAll [] rho1.{context=[]}) g ++ ")"
             ++ " = " ++ show [(v, nicer t g) | (v,t) <- each tree2]))
     let itau    = unJust (tree2.lookupS clas.var)       -- member type MUST mention it, see Classes.fr
         sigma2a = ForAll [] (RhoTau [] itau)
         validSigma rho = ForAll (map Tau.varkind (U.freeTVars [] rho)) rho
         sigma2 = validSigma sigma2a.rho
     E.logmsg TRACEG sym.pos (text ("class var  " ++ clas.var
             ++ "  in  " ++ nicer memc.typ g
             ++ " corresponds to  " ++ nicer sigma2 g))
 
     let tree3 = U.unifySigma g sigma2 symi.typ
         rho4  = U.substRho tree3 rho1
 
     let sigma4 = validSigma rho4      -- provide type variables
         bvars  = filter (`elem` sigma4.vars) instjsb ++ filter (`notElem` instjsb) sigma4.vars
         s4tree = TM.fromList sigma4.bound
         kinds  = map (maybe KVar id . s4tree.lookup) bvars
         bound = zip bvars kinds
         sigma5 = ForAll bound rho4      -- binds in correct order
     E.logmsg TRACEG sym.pos (text ("fake type for  " ++ nicer sym g ++ "  is  " ++ nicer sigma5 g))
     stio (sym.{typ=sigma5, depth = memc.depth}; 
        lazy (tauJT g (fst (U.returnType memc.typ.rho))))
fakeInstSigma _ _ _ = error "fakeInstSigma: bad args"
 
instFun :: Symbol -> Symbol -> QName -> StG [JDecl]
instFun symc symt mname = do
     g <- getST
     -- establish a fake type for instance member that matches the one of the instance
     -- cmem  <-  U.findV (MName (Symbol.name symc) (QName.base mname))
     let sym =  fromMaybe (error ("instFun not found: " ++ mname.nice g)) (g.findit mname)
     
     si            <-  symInfo sym
     (fsym, fjt)   <-  fakeInstSigma symc symt sym.{name <- QName.{base=mname.base}}
     
     let itreturns = autoboxed fjt
         wereturn  = autoboxed (returnType sym.rkind si.returnJT)
 
     -- let bndsV = sym.typ.bound
     --    bndsI = (Symbol.typ symt).bound
     let implies = impliesG g
         ctxs = [ ctx | ctx <- fsym.typ.rho.context,
                        not (any (`implies` ctx) symt.typ.rho.context)]
         ourCtxNms = drop symt.typ.rho.context.length ctxNames   -- ctx3, ctx4, ....
         isCAF = null ctxs && 
                    (if sym.{depth?} then sym.depth == 0 
                                     else ((0==) . length . snd . U.returnType) sym.typ.rho)
         csig = fsym.typ.{rho <- Rho.{context = symt.typ.rho.context ++ ctxs}}
         csym = fsym.{typ = csig}
 
     let cmeth = if sym.{expr?}
            then case sym.gExpr g of
                Just (v@Vbl {name=MName cname bs})
                     | cname `elem` (symc.name:symc.supers),
                       Just (meth@SymV{}) <- g.findit v.name,    -- just class method
                       isJust meth.nativ || isJust meth.expr = meth
                other -> sym -- instance method
            else sym.{typ = fsym.typ}
 
     mhbind <- compiling csym (instSym sym.pos cmeth fsym.typ)
 
 
     let constrformal = zipWith (makeConstraintArg g)  ctxs ourCtxNms
         func         = if isCAF 
                            then lazy  
                            else jtFunc (if sym.{depth?} then sym.depth else U.arity sym) 
     let -- constrargs   = map JAtom (take sym.typ.rho.context.length ctxNames)
         -- eosjt = erasedObj sjt
         result = JMethod {attr = attrs [JPublic, JFinal],
                             gargs = [],      -- ftargs,
                             jtype = func itreturns,     -- if higher then eosjt else sjt,
                             name = latinF ++ mangled mname.base,
                             args = constrformal,
                             body = JBlock impl}
         impl 
            | !isCAF && wereturn != itreturns
                        -- We must correct the type here since the stupid java
                        -- does not allow to pass Fun<X> when Fun<Object> is expected,
                        -- nor does it allow Fun<TList> when Fun<Lazy> is expected.  
                        = [ JLocal JMember{attr=attrFinal, 
                                    jtype = func wereturn, 
                                    name = "cheet", 
                                    init = Just mhbind.jex},
                            JReturn (JX.invoke [cheet] toS) ]
            | otherwise = [ JReturn mhbind.jex ]
            where
                cheet = JAtom "cheet"
                -- we need to pass type args explicitly for java6
                toS   = JX.JExMem{jex=cheet, name="toSuper", 
                    targs=[itreturns, wereturn]}
     stio [JComment ((nice fsym g) ++ " :: " ++ nice fsym.typ g), result]
 
 
 
{--
     Return the 'JName' of the worker function for the given symbol.
     [enum constructor]    @P.T.D@, actually a boxed int
     [newtype constructor] @P.T.mk@ (identity function)
     [product constructor] @P.T.mk@
     [sum constructor]     @P.T.D.mk@
     [let bound function/value] not usable, let bound definitions only accessible via 'Binding's
     [top level value]     @P.name@, @P.T.m.name@, @P.I.name@, @P.C.i.name@
     [top level function with constraints] @X.name.work@ (non static)
     [top level function, no constraints]  @X.name@
 -}
workerMethod :: Global -> Symbol -> JName
workerMethod g (sym@SymD {name, flds}) = case U.javaName g name of
         jname | Just (SymT {enum = true}) <- g.findit name.tynm = jname
               | null flds = memberOf jname "it"
               | otherwise = memberOf jname "mk"
workerMethod g (sym@SymV {name, depth = 0}) = U.javaName g name
workerMethod g (sym@SymV {name = Local{}})  = case g.gen.syminfo.lookup sym of
    Just si -> (U.javaName g sym.name).{base=workNameSI si}
    other -> error("No syminfo yet for " ++ nicer sym g)
workerMethod g (sym@SymV {name})            = U.javaName g name
workerMethod g _ = error "workerMethod: no SymV"
 
-- {--
--     Return the 'JName' of the lambda wrapper class for this symbol, if it has one.
--     This is mainly used to find the type argument for @*new*@.
-- 
--     [data constructors with arity 0]    'Nothing', has none
--     [data constructors with arity > 0]  'Nothing', singleton lambda made on the fly
--     [values] Nothing, has none
--     [let bound function] L/N/, where /N/ is unique. Only valid in scope of binding.
--     [top level function with constraints] @X.name@ (to be initialized with constraints)
--     [top level function, no constraints]  'Nothing', singleton lambda made on the fly
-- --}
-- wrapperClass :: Global -> Symbol -> Maybe JName
-- wrapperClass g (sym@SymD {}) = Nothing
--     -- null flds = Nothing
--     -- otherwise = Nothing
-- wrapperClass g (sym@SymV {name, depth, sid})
--     | depth == 0 = Nothing
--     | Local{} <- name = Just (JName "" ("L" ++ show sid))
--     | null sym.typ.rho.context = Nothing
--     | otherwise = Just (U.javaName g name)
-- wrapperClass g sym = error ("wrapperClass: bad arg " ++ sym.nice g)
-- 
-- 
-- {--
--     The name of the static variable that holds an instance of the 'wrapperClass'.
--     If this is a value or a nullary constructor, it returns the same as 'workerMethod'.
-- 
--     Note that let bound symbols must use the 'Binding' they are bound to.
-- 
--     [data constructors with arity > 0]   @M.T.D.ﬂmk@
-- --}
-- {-
-- wrapperInstance :: Global -> Symbol -> JName
-- wrapperInstance g (sym@SymD {strsig, flds})
--     | null flds = workerMethod g sym
--     | otherwise = (workerMethod g sym).{base <- (++ latinF)}
-- wrapperInstance g (sym@SymV {name}) 
--     | not name.isLocal = (workerMethod g sym).{base <- (++ latinF)}
-- wrapperInstance g sym = error ("wrapperInstance: bad arg " ++ sym.nice g)
-- -}
-- 
{--
     This is used for let bound functions and top level functions with constraints.
     Both have normally an @eval@ method that is lazy in all arguments and return type
     and a @work@ method that has at least one non lazy arg or the return type is not lazy.
 
     Sometimes it happens that he worker method would have the same method signature
     as the eval method. In that case, we can just do the computation in the @eval@ method
     instead of passing the arguments to @work@. Saves at least one stack frame.
 
     This function returns @"eval"@ if the @eval@ function can do the work, otherwise @"work"@.
 --}
workName :: JType -> [JType] -> String
workName rt ats  
    | all (Lazy Something ==) ats = "eval"
    | otherwise = "work"

workNameSI :: SymInfo -> String
workNameSI si = workName si.returnJT si.argJTs 

{--
    @makeConstraintDef (Ctx cname tau) "ctx3"@ = final Ccname<tau> ctx3
-}
makeConstraintDef g (Ctx {cname,tau}) s =
         JMember {
             attr = attrFinal,
             jtype = Ref (U.javaName g cname) [],
             name = s,
             init = Nothing}

  
{--
    @makeConstraintArg (Ctx cname tau) "arg3"@ = (final,  Ccname<tau>, "ctx3")
  -}
makeConstraintArg g ctx s = (def.attr; (ForAll [] (RhoTau [ctx] (Context.tau ctx))); def.jtype; def.name)
     where !def = makeConstraintDef g ctx s
 
 

{--
    the mode a certain argument is in, given strictness and sigma
    -}
-- argMode g s sig = jtRmode (argType g (Strictness.isStrict s) sig)

 
{--
     Adapt a 'Binding' to the required strictness and target type.
    --}
adaptBind :: Global -> Binding -> Strictness -> Binding
adaptBind g bind s
     = adaptSigmaWith (if Strictness.isStrict s then strict else lazy) g bind
        
 
--- adapt argument to wanted strictness
adaptArg g a s = adaptBind g (arg2Bind g a) s

--- instantiate 'Binding' for an Argument
instArg g a = adaptSigma g (arg2Bind g a)

{--
    Code for local non-functions
    
    - Does not have constraints on its type.
    - If it references local things from the same context including itself,
      it will be wrapped in a @class Let$1234 { ... }@
        
-}
innerCaf (sym@SymV {depth = 0, expr = Just dx}) binds !mutual = do
    x <- dx
    g <- getST
    let !rsimple = RSimple `member` sym.rkind
        comms = reverse [
                    JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
                    JComment (nicer sym.typ g), JComment (nicer x g)]
        !rtyp    = fst (U.returnTypeN 0 sym.typ.rho)
        !rlazy   = not sym.strsig.isStrict || not (RValue `member` sym.rkind)
        !jtype   = rhoJT g rtyp
        !rtype   = returnType sym.rkind jtype
        !name    = U.javaName g sym.name           -- P.foo

        cafX x   = JMember { attr = attrFinal, jtype = rtype,
                          name = name.base,
                          init = Just x}
        newu sc  = JNewClass jtDelayed [] (unCommentG g [vMeth sc])          -- new Unknown<R>() { ... }
        theU sc  = if rlazy then newu sc else (JX.invoke [] . JX.xmem "eval" ) (newu sc)
        vMeth sc = JMethod { attr = attrs [JPublic, JFinal],
                          gargs = [],
                          -- @eval@ absolutely must return Lazy<T>
                          jtype = autoboxed jtype,
                          name = "eval", args = [], body = JBlock sc }

        doscode = do
              let badguard = T.openCaseWhen g x
                  jthrow = [JThrow (JNew (Ref (JName "frege.runtime" "GuardFailed") []) [
                                                      JAtom (show (nicer sym g)),
                                                      JAtom (show sym.pos)])]
              code <- if not rlazy && not rsimple && not mutual
                 then do
                      -- U.hint sym.pos (text (nicer sym g ++ " gets initialized directly."))
                      compiling sym (genInit (JAtom name.base) rtype  x binds)                         
                 else compiling sym (genReturn      (autoboxed jtype) x binds)
              case badguard of
                  Just (Left x) -> do
                      E.warn (getpos x) (msgdoc ("guard (" ++ nicer x g ++ ") may evaluate to false."))
                      stio (code ++ jthrow)
                  Just (Right p) -> do
                      E.warn (getpos p) (msgdoc ("pattern guard (" ++ nicer p g ++ ") may fail to match."))
                      stio (code ++ jthrow)
                  Nothing -> stio code
        !decide = if not mutual
            then if rsimple 
                then do         -- lazy or not
                    ecode <- compiling sym (genExpr false rtype x binds)
                    let jexpr = (adapt ecode rtype).jex
                    return (comms ++ [JComment (show ecode), cafX jexpr])
                else do 
                    scode <- doscode
                    if rlazy 
                    then return (comms ++ [cafX (theU scode)])
                    else do
                        let me = JMember{attr=attrFinal, jtype=rtype, name=name.base, init=Nothing}
                            cafB = [me, JWhile (JBlock scode)]
                        return (comms ++ cafB)
            else do 
                scode <- doscode
                return (comms ++ [cafX (theU scode)])
    decide
 
innerCaf sym _ _ = do
    g <- getST 
    E.fatal sym.pos (text ("innerCaf: " ++ nicer sym g ++ " is not a CAF"))
{--
  * code for non-functions
  * - if there are constraints, we make a static function with constraint args.
  * - else, if the easy bit is off, we make an Delayed<type> and write the code in the eval function.
  * - else we just initialize
  -}
cafCode (sym@SymV {depth = 0, expr = Just dx}) binds = do
    x   <- dx
    g   <- getST
    let bnds = sym.typ.bound
        ctxNames = drop (length (envCtxs g)) GenJava7.ctxNames
 
    let (rtyp, _) = U.returnTypeN 0 sym.typ.rho
        symtyp = ForAll bnds rtyp
        -- mode  = argMode g (if rlazy then U else S[]) symtyp
        rlazy = not sym.strsig.isStrict 
                 || not (RValue `member` sym.rkind)
        rsimple = RSimple `member` sym.rkind
        recursive = not (RSafeTC `member` sym.rkind)        
        ctxs  = if null bnds then [] else sym.typ.rho.context
        cargs = zipWith (makeConstraintArg g) ctxs ctxNames
         -- constraints = map  (uncurry (makeConstraintDef g)) (zip ctxs ctxNames)
        jtype = sigmaJT g symtyp
        rtype = returnType sym.rkind jtype
    -- selfrec <- return 0
    let comp = if null cargs && rsimple
         then do
             ecode <- compiling sym (genExpr false rtype x binds)
             stio (Left ecode)
         else do
             let badguard = T.openCaseWhen g x
                 jthrow = [JThrow (JNew (Ref (JName "frege.runtime" "GuardFailed") []) [
                                                     JAtom (show (nicer sym g)),
                                                     JAtom (show sym.pos)])]
             code <- compiling sym (genReturn jtype x binds)
             case badguard of
                 Just (Left x) -> do
                     E.warn (getpos x) (msgdoc ("guard (" ++ nicer x g ++ ") may evaluate to false."))
                     stio (Right (code ++ jthrow))
                 Just (Right p) -> do
                     E.warn (getpos p) (msgdoc ("pattern guard (" ++ nicer p g ++ ") may fail to match."))
                     stio (Right (code ++ jthrow))
                 Nothing -> stio (Right code)
 
    escode <- comp
 
    let name  = U.javaName g sym.name           -- P.foo
        left (Left c) = c
        left _ =  error "no ecode"
        right (Right c) = c
        right _ =  error "no scode"
        ecode  = left escode
        scode  = right escode
        
        comms = reverse [
                 JComment (either show (const "no binding") escode),
                 JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
                 JComment (nicer sym.typ g), JComment (nicer x g)]
        jexpr = (adapt ecode rtype).jex
        static = JStatic
        publik = if sym.vis == Private then JPrivate else JPublic
        cafV  = JMember { attr = attrs [publik, JFinal, static], jtype = rtype,
                           name = name.base,
                           init = Just jexpr}
        newu  = JNewClass jtDelayed [] (unCommentG g [vMeth])          -- new Unknown<R>() { ... }
        theU
             | rlazy = newu
             | otherwise = (JX.invoke [] . JX.xmem "eval" ) newu
                                 
        vMeth = JMethod { attr = attrs [JPublic, JFinal],
                           gargs = [],
                           -- @eval@ absolutely must return Lazy<T>
                           jtype = autoboxed rtype,
                           name = "eval", args = [], body = JBlock scode }
        cafU  = JMember { attr = attrs [publik, JFinal, static], jtype = rtype,
                           name = cafV.name,
                           init = Just theU}
                                   
        cafF  = JMethod { attr = cafV.attr, jtype = rtype,
                           gargs = [], name = cafV.name,
                           args = cargs, body = JBlock fbody }
 
        fbody
            | recursive = [JReturn newu]
            | otherwise = scode
            
    let !caf = case (not (null cargs), rsimple) of
             --cargs  simple, selfrec
             
             (false, false)    -> cafU
             (false, true )    -> cafV
             (true,  _    )    -> cafF
             
    stio (reverse (caf:comms))
 
cafCode _ binds = error "cafCode: no caf"
-- --
-- --{--
-- -- * tell if a variable is implemented with a member or a class
-- -- -}
-- --varIsClass (sym@SymV {name, depth, rkind})
-- --    | depth > 0 = true
-- --    -- Local _ <- name = false
-- --    -- not (null (filter  (not • Context.checked) sym.typ.rho.context)) = true
-- --    | not (null sym.typ.bound) = true
-- --    | otherwise   = false
-- --    where
-- --        simple           = (rkind `.&.` 16) != 0
-- --        global (Local _) = false
-- --        global _         = true
-- --varIsClass _ = error "varIsClass: no var"
-- 
-- 
{--
    all the boilerplate code for a frege function
    -}
funCode (sym@SymV {expr = Just x}) binds = do
     g <- getST
     if g.toplevel then topFun   sym binds
                   else innerFun sym binds
funCode nofun binds = error "funClass: no function"
 
{--
    create new Lambda() { ...} from \x -> e
    -}
lambdaEx :: Expr -> TreeMap Symbol Binding -> StG Binding
lambdaEx (lam@Lam{pat,ex,typ=Just (sig@ForAll _ rho)}) binds = do
    g <- getST
    E.logmsg TRACEG (getpos ex) (text("lambdaEx: " ++ nice ex g ++ " :: " ++ nice rho g))
    rho <- TC.zonkRho rho
    idsym <- U.findV  VName{pack=pPreludeBase, base="id"}
    rkind <- T.returnExprKind [] idsym lam
    
    let depth = U.lambdaDepth ex + 1
        argNames = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava7.argNames
        (rty, atys) = U.returnTypeN depth rho
        lambdaTyp  = jtFunc depth retjt 
        fake = (U.patLocal (getpos lam) 0 "\\lambda").{depth}
        -- sjt  = sigmaJT g sig
        rjt  = rhoJT g rty
        -- ajts = mapSt (sigmaJT g) atys
        workerArgs = evalArgDef attrFinal atys argNames
        -- mode = jtRmode retjt
        retjt = returnType rkind rjt
     
    
    stmts <- compiling fake (genLambda retjt lam workerArgs binds) 

    let worker = JMethod {attr = attrs [JFinal, JPublic],
                          gargs = [],
                          jtype = autoboxed retjt,
                          name = "eval",
                          args = reverse workerArgs,
                          body = JBlock stmts}
        theClass =  JNewClass lambdaTyp [] (unCommentG g [
            JComment  ("worker rkind=" ++ show rkind),
            worker])
    return (newBind g sig theClass)
 
lambdaEx ex binds = do
    g <- getST
    E.fatal (getpos ex) (text ("lambdaEx: bad lambda " ++ nice ex g))    
 
{--
     Create @final Fun123 name = new Fun123() { ... }
  -}
innerFun (sym@SymV {expr = Just dx}) binds = do
     x <- dx
     g <- getST
     si <- symInfo sym
     E.logmsg TRACEG sym.pos (text ("innerFun: " ++ nice sym.name g ++ " :: "
              ++ nice sym.typ.rho g ++ ", depth=" ++ show sym.depth))
     rho <- TC.zonkRho sym.typ.rho
 
     let argNames = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava7.argNames
         argAttr = if RTailRec `member` sym.rkind then Attributes.empty else attrFinal
         -- (rty, _) = U.returnTypeN sym.depth sym.typ.rho
 
     let -- rjt        = rhoJT g rty
         wrkArgs    = argDefs argAttr si argNames
 
 
     let
         wrkType    = si.returnJT -- returnType sym.rkind rjt
         -- modew      = jtRmode wrkType
         wrkName    = workNameSI si
         letName    = U.javaName g sym.name
         lambdaTyp  = jtFunc sym.depth wrkType
         classTyp   = Ref letName.{base <- ("F" ++)}  []
         thisName   = "this"  ++ show sym.sid
         thisBind   = Bind{stype = nicer sym.typ g,
                            ftype = sym.typ,
                            jtype = Lambda,
                            jex   = JAtom thisName}
         innerbinds = insert sym thisBind binds
 
     stmts        <- compiling  sym (genFunction sym wrkType wrkArgs innerbinds)
     lMethod      <- lazyMethod sym
 
     let worker = JMethod {attr = attrs [JFinal, JPublic],
                           gargs = [],
                           jtype = if wrkName == "eval" then autoboxed wrkType else wrkType,
                           name = wrkName,
                           args = wrkArgs,
                           body = JBlock (thisAssign:stmts)}
         -- final Lambda123 this123 = this;
         thisAssign = JLocal (JMember {attr = attrFinal, jtype=classTyp, name = thisName,
                                         init = Just (JAtom "this")})
         letVar = JMember { attr = attrFinal, jtype = classTyp, name = letName.base,
                             init = Just (JNew classTyp []) }
         defs
             | wrkName == "eval" =  [worker.{args <- reverse}]
             | otherwise      =  [worker, lMethod]
         theClass = JClass { attr = attrFinal, jtype = classTyp,
                             extend = Just lambdaTyp,
                             implement = [], defs}
  
     stio (unCommentG g [JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
         JComment (nicer sym.typ g),
         JComment (nicer x g),
         theClass, letVar
         ])
innerFun sym binds = error "innerFun: no function"


--- Generate code for a top level function 
topFun (sym@SymV {expr = Just dx}) binds = do
    x <- dx
    g <- getST
    si <- symInfo sym
    E.logmsg TRACEG sym.pos (text ("topFun: " ++ nice sym.name g ++ " :: "
              ++ nicer sym.typ.rho g 
              ++ ", depth=" ++ show sym.depth
              ++ ", rstate=" ++ show sym.rkind))
 
    let argNames    = drop (sum (map Symbol.depth g.genEnv)) GenJava7.argNames
        argAttr     = if RTailRec `member` sym.rkind then BitSet.empty else attrFinal 
        -- (rty, _) = U.returnTypeN sym.depth sym.typ.rho
        -- staticWorker = null sym.typ.rho.context
        constrargs  = map unFinal (zipWith (makeConstraintArg g)  sym.typ.rho.context  ctxNames)
        -- when this is a tail recursive function, we write "Ctx fctx$1"
        unFinal (farg@(attr,  sig, t, nm))
            | RTailRec `member` sym.rkind   = (empty, sig, t, nm++"f")
            | otherwise                     = farg
        -- rjt         = rhoJT g rty
        wrjt        = si.returnJT
        workerArgs  = argDefs argAttr si argNames
        -- modew       = jtRmode wrjt  -- wmode sym.rkind
        workerName  = (U.javaName g sym.name).base -- if staticWorker then (workerMethod g sym).base else workName g sym
 
    stmts           <- compiling sym (genFunction sym wrjt (workerArgs) binds)
     -- lClass <- prepareLazy sym  {- if staticWorker
     --             then return (JComment "has static worker")
     --             else lazyClass sym -}
 
    let worker      = JMethod {attr = attrs [JFinal, JPublic, JStatic],
                           gargs = targs sym.typ,
                           jtype = wrjt,
                           name  = workerName,
                           args  = constrargs ++ workerArgs,
                           body  = JBlock stmts}
 
        defs        = [{-lClass,-} worker]
           
    stio ([JComment ((nicer sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
         JComment (nicer sym.typ g),
         JComment (nicer x g)] ++ defs)
topFun _ _ = error "topFun: no function"


returnTau sigma = (fst • U.returnType) (Sigma.rho sigma)
sigmaTau f (ForAll [] (RhoTau [] ty)) = f ty
sigmaTau f (ForAll [] rhofun) = sigmaTau f (ForAll [] (tauRho rhofun))
sigmaTau f _ = Nothing
 
niArr s = strhead s (length s - 2)
 
niSpecial g ty
     | Just _ <- U.isUnit ty        = true
     | Just _ <- U.isMaybe ty       = true
     | Just _ <- U.isException g ty = true
     | Just _ <- unST ty          = true
     -- Just x <- U.isList ty        = true
     | otherwise = false
 

methClass SymV {nativ = Just _, over = _:_} = return [] -- no code at all for overloaded  
methClass (sym@SymV {nativ = Just item, pur, typ}) = do
         g <- getST
         si <- symInfo sym
         return (methCode g sym si)
methClass _  = undefined


--- Tells if a native symbol is wrapped 
wrapped g (sym@SymV {nativ = Just item, throwing}) = not (null throwing) || niSpecial g rty
     where
         (rty, _) = U.returnType sym.typ.rho
wrapped g SymV {} = false
wrapped g SymD {} = false
wrapped g _ = error "wrapped: no symv"
 
{--
    Tell if a native function must be called through it's wrapper.
  
    This is the case when it is wrapped for some other reason
    than that the return type is 'Maybe'.
  -}
wrappedOnly g (sym@SymV {nativ = Just _, throwing}) 
        = not (null throwing) || niSpecial g rty && isNothing (U.isMaybe rty)
    where
        (rty, _) = U.returnType sym.typ.rho
wrappedOnly g sym = error "wrappedOnly - no native function"
-- 
-- 
--- returns a binding for a direct call of a native method
nativeCall g (sym@SymV {nativ = Just item}) abinds = newBind g bsig (call jrty args)
    where
        taus = [ tau | Just tau <- map (sigmaTau Just) sigmas ]
        brty = baserty rty
        bsig = ForAll [] (RhoTau [] brty)
        args | [tau] <- taus, Just _ <- U.isUnit tau = []   -- no arguments
             | otherwise = zipWith (argEx g)  abinds taus
        bjt = tauJT g brty
        jrty = strict  bjt
        -- retmode = maxStrict jrty         
        (rty, sigmas) = U.returnType sym.typ.rho
        argEx g bind tau
             | Just x <- U.isMaybe tau = JQC checknothing (JAtom "null") (justm1 x).jex
             -- Just x <- arrayTau g tau = JCast x bind.jex
             | otherwise = sbind.jex
             where
                 sbind = primitiveBind  bind
                 checknothing = JBin con "==" (JAtom "0")
                 con = JInvoke (JExMem sbind.jex "_constructor" []) []
                 justm1 x = adaptSigma g  Bind{stype = nicer x g, 
                                 ftype = ForAll [] (RhoTau [] x), 
                                 jtype = Lazy Something,            -- i.e. Object 
                                 jex   = m1ex}
                 m1ex = JExMem just "mem1" []
                 just = JInvoke (JExMem sbind.jex "_Just" []) []
        baserty r
             | Just (_, x) <- unST r       = baserty x
             | Just (_, x) <- U.isException g r = baserty x
             | Just x <- U.isMaybe r       = baserty x
             | Just _ <- U.isUnit r        = r
             | otherwise                   = r
        call jrty args = case niKind item of
             NIOp -> case args of
                 [a,b] -> JBin a item b
                 [a]   -> JUnop item a
                 _     -> JAtom "null"           -- error was flagged before
             NINew -> JNew jrty args
             NICast -> case args of
                 [a] -> JInvoke (JAtom item) args    -- was: JCast (Ref (JName "" item) []) a
                 _   -> JAtom "null"
             NIMethod -> case args of
                 (a:as) -> case item of
                     "clone" -> JCast jrty (JInvoke (JExMem a item []) as) -- due to java brain damage
                     _ -> JInvoke (JExMem a item []) as
                 _ -> JAtom "null"
             NIMember -> case args of
                 [a] -> (JExMem a (tail item) [])
                 _ -> JAtom "null"
             NINewArray -> JNewArray jrty (head args)
             -- NINewArray -> JNewArray  (Ref (JName "" (niArr item)) []) (head args)
             NIStatic -> case sigmas of
                 (_:_) -> JInvoke (JAtom item) args
                 _ -> JAtom item
             NIArrayGet -> case args of
                [a,b] -> JArrayGet a b
                _     -> JAtom "bad array get"      -- error was flaggend before
             NIArraySet -> case args of
                [a,b,c] -> JBin (JArrayGet a b) "=" c
                _     -> JAtom "bad array set"      -- error was flagged before 
nativeCall g sym abinds = error ("nativeCall: no function " 
    ++ show sym.pos.first.line
    ++ ", " ++ nicer sym g)
-- 
wrapCode g jreturn rtau (sym@SymV {nativ = Just item, throwing}) abinds
    | Just (stau, atau) <- unST rtau = let
            -- sjt = tauJT g stau           -- type #1 for parameterization of ST s a
            ajt     = tauJT g atau          -- return type of the ST action
            ssig    = ForAll [] (RhoTau [] stau)
            mktup x = JReturn x
            code    = wrapCode g mktup atau sym abinds 
            try     = JBlockX "try" code
            rbody
                | null throwing   = code
                | otherwise = try : catches
                where
                    catches = map mkCatch throwing
                    mkCatch t = JBlockX (catch t) [JThrow wrap]
                    wrap = (JX.invoke [JAtom "ex"] . JX.static . memberOf jnWrapped)
                            "wrapIfNeeded" 
                
            ret     = jreturn fun -- (JNew jtFun [mkST])
            fun     = JNewClass lambda [] [rMethod]
            lambda  = jtFunc 1 ajt
            rMethod = JMethod {attr = attrs [JFinal, JPublic], gargs=[],
                                jtype = autoboxed ajt, name = "eval",
                                args = [(attrFinal, ssig, Something, "_state")],
                                body = JBlock rbody}
        in [ret]
    | Just (exs, mtau) <- U.isException g rtau = let
            -- mjt = tauJT g mtau
            -- xjt = tauJT g (TCon {pos = sym.pos, name = TName pPreludeBase "JException"})
            
 
            code    = wrapCode g (jreturn . right) mtau sym abinds
            try     = JBlockX "try" code
            mkCatch exs go = case U.isException g exs of
                    Just (lty, rty) -> JBlockX (catch rty) r : mkCatch lty (left . go)
                    Nothing -> [JBlockX (catch exs) [(jreturn . go) $ (JAtom "ex")]]
                where
                    r = [(jreturn . go . right) (JAtom "ex")]
                    
            -- catch   = JBlockX "catch (Exception ex)" [left]
        in try : reverse ( mkCatch exs left )
    | Just atau <- U.isMaybe rtau = let
            -- ajt    = tauJT g atau
            -- bind   = nativeCall g sym abinds
            mkmb   = {- case isPrimitive ajt of
                 Just prim ->
                     JInvoke (JStMem (JName base ("_" ++ prim++ "ToMaybe")) []) [bind.jex]
                 Nothing   -> -}
                     JInvoke (JStMem (JName base "_toMaybe") []) [bind.jex]
         in [jreturn mkmb]
    -- | Just atau <- U.isList rtau = let
    --         ajt    = tauJT g atau
    --         -- bind   = nativeCall g sym abinds
    --         mklst  = case isPrimitive ajt of
    --              Just _  -> bind.jex
    --              Nothing -> JInvoke (JStMem (JName base "_toList") []) [bind.jex]
    --      in [jreturn mklst]
     | Just _ <- U.isUnit rtau = let
            -- bind   = nativeCall g sym abinds
            unit   = JStMem (JName (base ++ ".TUnit") "Unit") []
         in [JEx bind.jex, jreturn unit]
     | otherwise = [jreturn (strictBind bind).jex]
     where
        bind    = nativeCall g sym abinds
        base    = "PreludeBase"
        right x = (JInvoke (JStMem (JName (base ++ ".TEither.DRight") "mk") []) [x])
        left  x = (JInvoke (JStMem (JName (base ++ ".TEither.DLeft")  "mk") []) [x])
        catch rty = case tauJT g rty of
                        Nativ{typ, typeargs} -> "catch (" ++ typ ++ " ex)"
                        other -> error ("bad exception type " ++ show other)        
wrapCode g jreturn rtau sym abinds = error "wrapCode: no SymV"
 
 
{--
    code for native functions and/or members
  -}
methCode :: Global -> Symbol -> SymInfo -> [JDecl]
methCode g (sym@SymV {nativ = Just item}) si = [
        JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
        JComment (nicer sym.typ g),
        JComment item] ++
                (if arity > 0 then defs 
                 else if wrapped g sym || niKind item != NIStatic 
                    then [member]
                    else [])
    where
        rjt         = tauJT g rty
        rArgs       = evalArgDef attrFinal si.argSigs argNames
        wArgs       = argDefs attrFinal si argNames
        bnds        = sym.typ.bound
        name        = U.javaName g sym.name                        -- X.foo
        -- fname       = {-U.fName-} name                                 -- X.Ffoo
        ftargs      = targs sym.typ                                -- <a,b,c>
        -- ftype       = (Ref (fname) ftargs)                         -- Ffoo<a,b,c>
        -- dftype      = defining ftype
        args        = if haswrapper then wArgs else rArgs
        haswrapper  = arity > 0 && wrapped g sym || (not (null bnds))
        -- callWrapper = (toBoxed bndWrapper).jex
        -- bndWrapper  = bndWcode invWrapper
        -- invWrapper  = JInvoke (JX.static name)
        jreturn     = if arity > 0 then JReturn else JEx
        bndWcode  x = newBind g (ForAll [] (RhoTau [] rty))  x
 
        wcode       = if wrapped g sym
                        then wrapCode g jreturn rty sym (map (instArg g) args)
                        else let
                                bind = nativeCall g sym (map (instArg g) args)
                            in [jreturn bind.jex]
        wrappers    = if haswrapper then [{- inst, -} wrapper] else [{-inst-}]
        wrapper     = JMethod {attr = attrs [JPublic, JStatic, JFinal],
                                 gargs = ftargs, jtype = si.returnJT, name = name.base,
                                 args = wArgs, body = JBlock wcode}
        defs        = wrappers
        unex  [(JEx x)] = (strictBind (bndWcode x)).jex
        unex  _ = error "unex: need list with 1 ex"
        member = JMember {attr = attrs [JPublic, JStatic, JFinal],
                          jtype = rjt,
                          name = (U.javaName g sym.name).base,
                          init = Just (unex wcode)}
 
        (rty, atys) = U.returnType sym.typ.rho
        arity       = length atys
 
methCode g sym _ = Prelude.error ("line " ++ show sym.pos.first.line 
                    ++ ": can not compile " ++ nice sym g)
         
 
{--
    > compiling symbol action 
    
    run @action@ with @symbol@ in the current compiling environment
    -}
compiling sym action = do
    -- g <- getST
    changeST Global.{genEnv <- (sym:)}
    r <- action
    changeST Global.{genEnv <- tail}
    stio r
 
{--
    - invokes 'genLambda' to generate code for a function
    - wraps the code in a while statement for tail calling functions
    -}
genFunction (sym@SymV {expr = Just dex}) rmode args binds = do
        -- g <- getST
        ex <- dex
        if not (RTailRec `member` sym.rkind) -- if (sym.rkind `.&.` T.rkTail) == 0
            then genLambda rmode ex args binds
            else do
                g <- getST
                let
                    ctxs  = zipWith (makeConstraintArg g)  sym.typ.rho.context  ctxNames
                    fargs = [ (attrFinal, sig, jt, nm ++ "f") | (_,sig,jt,nm) <- args ]
                    decls = [ JMember { attr = attrFinal, jtype = jt,
                                        name = nm,
                                        init = Just (JAtom (nm++"f"))}
                                            | (_,_,jt,nm) <- ctxs ]
                            ++ [ JMember { attr = attrFinal,
                                         jtype = jt,
                                         name = nm ++ "f",
                                         init = Just (JAtom nm)} | (_,sig,jt,nm) <- args ]
                    stmts = map JLocal decls
                code <- genLambda rmode ex fargs binds
                stio [JCond "tailrecursion: while" (JAtom "true") (stmts ++ code)]
                 
genFunction sym rmode args binds = error "genFunction: no function"
 

{--
  * Code for outer lambdas.
  *
  * Set's up a 'Binding' for the corresponding method argument and
  * 'match'es its pattern against it with the enclosed expression as continuation.
  -}
genLambda rm (Lam {pat, ex}) ((arg@(_, _, _, s)) : args) binds = do
    g <- getST
    ps <- T.patternStrictness pat
    let komplett = T.patsComplete g [pat]
        badguard = T.openCaseWhen g ex
        assert = isNothing komplett
         -- mustthrow = not assert && isNothing badguard
        margs = map JAtom [show ((last g.genEnv).name.nice g),
                                                 show (getpos pat)] ++ [JAtom s]
        -- construct new NoMatch("Module.foo", 42, arg$1)
        jthrow = [JThrow (JNew (Ref (JName "frege.runtime" "NoMatch") []) margs)]
 
    (_, code) <- match assert pat (adaptArg g arg ps)
                            (genLambda rm ex args) binds
    case komplett of
         Just p -> do
             E.warn (getpos pat) (msgdoc ("function pattern is refutable, "
                             ++ "consider adding a case for  "
                             ++ nicer p g))
             stio (code ++ jthrow)
         _ -> case badguard of
             Just (Left x) -> do
                 E.warn (getpos x) (msgdoc ("guard (" ++ nicer x g ++ ") may evaluate to false."))
                 stio (code ++ jthrow)
             Just (Right p) -> do
                 E.warn (getpos p) (msgdoc ("pattern guard (" ++ nicer p g ++ ") may fail to match."))
                 stio (code ++ jthrow)
             Nothing -> stio code
 
 
genLambda rm x [] binds {-
    | Lam {pat} <- x = do
        g <- getST
        E.fatal (getpos x) (text ("genLambda: argument for " ++ nice pat g ++ " missing"))
    | otherwise -} = do
        g <- getST
        E.logmsg TRACEG (getpos x) (text ("genLambda[]: " ++ nice x g)) 
        genReturn rm x binds
 
genLambda _ x _ _ = do
    g <- getST
    E.fatal (getpos x) (text ("genLambda: bad expression: " ++ nice x g))

genCaseStmt :: (JX -> [JStmt]) -> JType -> Expr -> TreeMap Symbol Binding -> StG [JStmt] 
{--
  * The code for case statements can and will be optimized in various ways.
 
  * First, if the case expression is of the form @Con x1 x2 ... xn@, we can avoid
  * actual construction of the value if all the patterns are of
  * the form @Con p1 p2 ... pn@ or @_@ or @v@ where v is not used on the right hand side.
  * Indeed, every definition of a function with multiple arguments and more than one
  * alternative
  * > fun p1a p1b p1c = alt1
  * > fun p2a p2b p2c = alt2
  * > ...
  * results in code like
  * > \_a\_b\_c -> case (_a, _b, _c) of
  * >    (p1a, p1b, p1c)  -> alt1
  * >    (p2a, p2b, p2c)  -> alt2
  * >    ...
  * so naive implementation would cause an extra tuple construction on every function
  * call - this tuple would be created just to get deconstructed right away.
  *
  * Second, if we know that the set of patterns covers all possibilities, we
  * can avoid if-statements on the last alternative. In addition, we do not need
  * to arrange for the case that the pattern is not matched.
  * Therefore, we have a sophisticated algorithm to find this out, see 'T.patsComplete'
  *
  * The generated java code looks like this:
  * >  // compute case expression if needed
  * >  if (p1a matches) {
  * >    if (p1b matches) {
  * >        if (p1c matches) {
  * >            code for alternative1
  * >  }}} // fall through to next alternative
  * >  if (p2a matches) {
  * >        ... like above ...
  * >  }
  * >  ... yet more alternatives ....
  * >  throw new NoMatch("xy.fr", 345, case expression)
  -}
genCaseStmt jret rm (x@Case {ckind,ex=cex,alts=calts}) binds = do
         g <- getST
     -- case Con a b c  ... avoid actual creation of value unless a pattern is not
     -- itself a constructor application or a variable that is not referenced in its scope
         capp <- constrApp cex                      -- Just (Con, args) if this is Con a1 a2 ... an
         pats <- foldSt conUVarAlt true calts        -- true if all patterns are Con _ or _
         stri <- patternStrictness (head calts).pat -- strsig of 1st pattern
         -- rmex <- patternRMode (head calts).pat
         bcex <- genExpression false (if stri.isStrict then strict else lazy) cex binds              -- code for ordinary expression
         let makeBexs                                -- binds for cex or constr args
                 | pats, Just (con, xs) <- capp = case stri of
                         S ss -> mapSt exStr (zip xs (ss ++ allLazy))
                         U    -> mapSt exStr (zip xs allLazy)
                 | otherwise = stio [bcex]
         bexs <- makeBexs
         let con = if pats then maybe Nothing (Just • fst) capp else Nothing      -- constructor in case ex, if any
             complete
                 | T.caseOtherwise g x = Nothing         -- case true of true -> ...
                 | otherwise = T.patsComplete g (map CAlt.pat ralts)
             -- ralts are the alternatives that have no guard that could fail
             -- only the patterns of those alts are considered in deciding
             -- whether to throw exceptions or not
             -- walts are the alternatives that have an open case when
             (walts, ralts) = partitioned (isJust • T.openCaseWhen g • CAlt.ex) calts
             -- We will give a hint as to which guard is most likely
             -- causing trouble. If the patterns would be complete if there were
             -- no guards, then it is most likely the guard on an otherwise irrefutable
             -- pattern, if there is none, we assume it is the guard of the last alternative
             -- that has a guard.
             badguard = case T.patsComplete g (map CAlt.pat calts) of -- would it be complete
                 Just _  -> Nothing       -- case could not be made safe by adding guards
                 Nothing -> case filter (not • T.patternRefutable g • CAlt.pat) walts of
                     walt:_ -> T.openCaseWhen g walt.ex
                     []     -> case reverse walts of
                         walt:_ -> T.openCaseWhen g walt.ex
                         []     -> Nothing
 
             comment = sComment ("case  " ++ nice cex g ++ "  ... "
                         ++ (if ckind == CWhen then "(guard)" else ""))
             throw binds
                 | ckind == CWhen  = stio []                     -- guards always fall through
                 | Nothing <- con,
                   [bex1] <- binds = throwEx (strictBind  bex1)
                 | otherwise       = throwEx (strictBind  bcex)      -- construct case ex for throw
             throwEx arg
                 | isJust complete, Just (Left x) <- badguard = do
                     when (ckind != CNoWarn) do
                         E.warn (getpos x) (msgdoc ("guard (" ++ nicer x g ++ ") may evaluate to false."))
                     stio (jthrow arg)
                 | isJust complete, Just (Right p) <- badguard = do
                     when (ckind != CNoWarn) do
                         E.warn (getpos p) (msgdoc ("pattern guard (" ++ nicer p g ++ ") may fail to match."))
 
                     stio (jthrow arg)
                 | Just p <- complete = do
                     when (ckind != CNoWarn) do
                         E.warn (last calts).pat.getpos (msgdoc ("pattern match is not exhaustive, "
                                 ++ "consider adding a case for  "
                                 ++ nicer p g))
                     stio (jthrow arg)
                 | otherwise = stio []                   -- no throw neeeded
 
             throwargs exb = map JAtom [show ((Prelude.last g.genEnv).name.nice g),
                                                 show (getpos x)] ++ [Binding.jex exb]
             jthrow exb = [JThrow (JNew (Ref (JName "frege.runtime" "NoMatch") []) (throwargs exb))]
 
         (nbexs, code) <- genAlts complete binds [] con bexs calts    -- make alternatives
         jthrow <- throw nbexs                               -- make throw statement
         stio (comment : concat (reverse (jthrow:code)))
 
     where
         genAlts complete binds codes con bexs ((calt@CAlt {pat, ex}):alts) = do
             g <- getST
             let last = finalAlt g calt || null alts
             -- when = T.openCaseWhen g ex
                 noif = last && isNothing complete
                 poss = map (getpos • CAlt.pat)  alts
                 unreachable p = E.warn p (text "equation or case alternative cannot be reached.")
             (codes, nbexs) <- genAlt noif binds codes con bexs calt
             if last
                 then do
                     when (ckind != CNoWarn) do
                         foreach poss unreachable
                     stio (nbexs, codes)
                 else genAlts complete binds codes con nbexs alts
         genAlts complete binds codes con bexs alts = error "genAlts: null alts"
 
         genAlt noif binds codes mbcon bexs (alt@CAlt {pat,ex})
             | Nothing  <- mbcon = do
                 g <- getST
                 if patternRefutable g pat && ckind == CNormal
                 then do
                    (rbex, code1) <- realize "$" (head bexs)
                    (nbex, code) <- match noif pat rbex (genStmts jret rm ex) binds
                    stio ((altComm g:(code1++code)):codes, [nbex])
                 else do
                    (nbex, code) <- match noif pat (head bexs) (genStmts jret rm ex) binds
                    stio ((altComm g:code):codes, [nbex])  
                 
                 
             | Just con <- mbcon = do
                 g <- getST
                 stri <- patternStrictness pat
                 case pat of
                     PCon {qname} -> do
                         sym <- U.findD qname
                         if sym.sid == Symbol.sid con then do
                                 let nbexs = case stri of
                                         S ss -> zipWith (bexStr g) bexs (ss ++ allLazy)
                                         _    -> bexs
                                 code <- matchCon noif pat con nbexs (genStmts jret rm ex) binds
                                 g <- getST
                                 stio ((altComm g:code):codes, nbexs)
                             else do
                                 E.warn (getpos pat) (text "case alternative will never be taken")
                                 stio ([]:codes, bexs)
                     _  -> do
                         g <- getST
                         -- uvar <- conUVarAlt true alt
                         -- if uvar then do
                         code <- genStmts jret rm ex binds
                         stio ((altComm g:code):codes, bexs)
             | otherwise = undefined
             where
                 altComm g = sComment ("... of  " ++ nice pat g ++ " -> " ++ nicer ex g)
 
 
         exStr  (ex, stri)
             | Strictness.isStrict stri = genExpression false strict  ex binds
             | otherwise                = genExpression false lazy    ex binds
         bexStr g bind stri
             | Strictness.isStrict stri = strictBind bind
             | otherwise = bind
             -- check if an expression is a constructor application
         constrApp (ex@App _ _ _) = case map fst (flatx ex) of
             Con {name}:xs -> do
                 sym <- U.findD name
                 if length sym.flds == length xs
                     then stio (Just (sym, xs))
                     else stio Nothing            -- for example:  case (,) a of mktuple -> mktuple b
             _ -> stio Nothing
         constrApp _ = stio Nothing      -- for example: let a = 1 in Just a
         -- check if a pattern is a constructor application or an unused variable
         conUVarAlt false _ = stio false
         conUVarAlt true (CAlt {pat = PCon {pos}}) = stio true
         conUVarAlt true (CAlt {pat = PVar {var,uid}, ex}) = do
             sym  <- U.findV (Local uid var)
             refs <- T.references [sym.sid] ex
             stio (refs == 0) 
         conUVarAlt _ _ = stio false
         -- check if there could match anything else after this alternative has matched
         finalAlt g (CAlt {pat,ex})
             | T.patternRefutable g pat = false
             | Just _ <- T.openCaseWhen g ex = false
             | otherwise = true
genCaseStmt jret rm nocase binds = error "genCaseStmt: no case"

--- runs 'genStmts' to generate code that returns the value
genReturn :: JType -> Expr -> TreeMap Symbol Binding -> StG [JStmt]
genReturn jt ex tree = genStmts return jt ex tree 
    where
        return x = [JReturn x]

{--
    Generate code like:
    
    > while (true) { block }
    
    where _block_ uses
    
    > atom = expr;
    > break;
    
    instead of @return@
    
    This is used to initialize non-simple 'innerCaf's
-}
genInit :: JX -> JType -> Expr -> TreeMap Symbol Binding -> StG [JStmt]
genInit jx jt ex tree = genStmts assignAndBreak jt ex tree
    where 
        assignAndBreak result = [JAssign jx result, JEx (JAtom "break")]
        
        
{--
  * [usage] @genStmt rkind expression bindings@
  * [returns] A list of statements where the last one is a @return@
  *           or a @continue@ for a tailcall or a @throw@ from an
  *           incomplete case statement
  * This is called for return expressions only.
  -}
genStmts :: (JX -> [JStmt]) -> JType -> Expr -> TreeMap Symbol Binding -> StG [JStmt]
genStmts jret rm (x@Case {ckind,ex=cex,alts=calts}) binds = genCaseStmt jret rm x binds
 
genStmts jret rm (x@Let {env, ex}) binds = do
     case env of
         [k] -> do
             symv <- U.findV k
             case symv.expr of
                 Just vx
                     | symv.depth == 0,
                       symv.strsig.isStrict,
                       RSimple `member` symv.rkind,
                       RhoTau [] t <- symv.typ.rho = do
                                        vx <- vx
                                        genStmts jret rm (cas vx) binds
                     where
                         cas vx = Case CWhen vx [alt] x.typ
                         alt = CAlt {ex, pat = PVar symv.pos symv.name.uid symv.name.base}
                 _ -> genLet jret rm x binds
         _ -> genLet jret rm x binds
 
genStmts jret rm (x@Let {env,ex}) binds = genLet jret rm x binds
 
genStmts jret rm (x@(Ifte c t e _)) binds {-| not (T.isSimple x) -} = do
         g <- getST
         cbnd <- genExpression false strict c binds
         tstm <- genStmts jret rm t binds
         estm <- genStmts jret rm e binds
         stio [sComment (nicer x g), 
            JCond "if" (strictBind cbnd).jex tstm, 
            JBlockX "else" estm]
 
 
genStmts jret rm ex binds
     {- | T.isSimple ex -} = do                                -- return or tailcall
         g   <- getST
         case ex of
             App _ _ _
                 | Vbl {name}:args <- map fst (flatx ex),
                   Just (sym@SymV {sid}) <- g.findit name,
                   sid == (head (g.genEnv)).sid,
                   length args == sym.depth = do
                        -- tail call
                        let argNames = map (++"f") (take (length sym.typ.rho.context) ctxNames) ++
                                    drop (sum (map Symbol.depth (tail g.genEnv))) GenJava7.argNames 
                        call <- genExpr true rm ex binds
                        case call.jex of
                            JInvoke{args} -> do
                            -- si <- symInfo sym
                            -- abinds   <- sequence (zipWith genEx si.argJTs args)
                                let assigns = zipWith JAssign (map JAtom argNames) args --(map Binding.jex abinds)
                                stio (comment:assigns ++ [JEx (JAtom "continue tailrecursion")])
                            JNewClass{
                                args=[], 
                                decls=[JMethod{
                                    name="eval", 
                                    args=[], 
                                    body=JBlock [JReturn JInvoke{args}]}]} -> do
                                let assigns = zipWith JAssign (map JAtom argNames) args --(map Binding.jex abinds)
                                stio (comment:assigns ++ [JEx (JAtom "continue tailrecursion")])
                            _ -> do
                                E.error (getpos ex) (text "can't make tail recursion for"
                                    </> PP.nest 4 (text (nicer ex g))
                                    </> text "from"
                                    </> PP.nest 4 (PP.group (anno call.jex)))
                                return [JEx (JAtom "continue tailrecursion")]
                 where
                    comment = sComment ("tailcall  " ++ nicer ex g)
                    -- genEx tt aex = genExpr false tt aex binds
             _ = do
                 -- small hack to find out if this is actually a return ...
                 let realReturn
                        | [JReturn _]  <- jret (JAtom "x") = true
                        | otherwise = false  
                 bnd <- genExpr realReturn rm ex binds
                 stio (  sComment ("return " ++ show rm ++ "  " ++ nicer ex g)
                       : sComment (show bnd)
                       : jret bnd.jex)
 

genLet :: (JX -> [JStmt]) -> JType -> Expr -> TreeMap Symbol Binding -> StG [JStmt] 
genLet jret rm (x@Let {env,ex}) binds = do
         g <- getST
         syms <- mapSt U.findV env
         case syms of
            [sym] = do
                c <- selfReferentialCAF sym
                if c then genLetClass syms else genLetSingle sym
            _     = genLetClass syms
         
     where
         selfReferentialCAF (sym@SymV {expr = Just x, depth = 0}) = do
            refs <- x >>= T.references [sym.sid]
            return (refs > 0)
         selfReferentialCAF _ = return false
         
         -- generate a single inner function or a non self recursive caf
         genLetSingle sym = do
            g <- getST
            let letbinds = mkbind g JAtom binds sym
            decls <- gen false letbinds sym
            stmts <- genStmts jret rm ex letbinds
            return (comment g : (map JLocal decls ++ stmts))
            
         -- generate declaration of inner function or caf
         gen mutual binds sym
            | sym.depth == 0 = innerCaf sym binds mutual 
            | otherwise      = innerFun sym binds 
         
         -- set up simple bindings, generate the mutually dependent items in a class
         -- instantiate that class and make bindings that access the bindings from outside
         genLetClass syms = do
            g <- getST
            let innerbinds = fold (mkbind g JAtom) binds syms
            decls <- mapM (gen true innerbinds) syms
            u <- uniqid
            let letcl = JClass{attr = attrFinal, 
                    jtype, extend = Nothing, implement = [], defs = concat decls}
                -- udecls = map (\JLocal decl -> decl) decls
                jtype = Ref{jname = JName{qual="", base}, typeargs=[]}
                base = "Let$" ++ show u
                name = "let$" ++ show u
                var = JMember{attr=attrFinal, jtype, name, 
                        init = Just (JNew jtype [])}
                member n = JExMem{jex = JAtom name, name=n, targs=[]}
                letbinds = fold (mkbind g member) binds syms
            stmts <- genStmts jret rm ex letbinds
            return (comment g : JLocal letcl : JLocal var : stmts) 
         comment g = sComment (nicer x g)
         mkbind :: Global -> (String -> JX)  -> TreeMap Symbol Binding -> Symbol -> TreeMap Symbol Binding
         mkbind g prefix binds sym = insert sym bind binds 
            where
                bind = Bind{stype=nicer sym.typ g, 
                            ftype=sym.typ, jtype=bjt, 
                            jex=prefix name}
                bjt = mode jt
                jt  = sigmaJT g sym.typ
                mode = if sym.depth > 0 then strict
                        else if RValue `member` sym.rkind
                            then strict else lazy
                name = (U.javaName g sym.name).base
genLet jret _ ex binds = do
     g <- getST
     E.fatal (getpos ex) (text("genLet: not a let  " ++ nice ex g))
 
 
envCtxs g = [ ctx | s <- reverse (Global.genEnv g),
                                     not (null (Symbol.typ s).bound),
                                     ctx <- (Symbol.typ s).rho.context ]
 
 
resolveConstraint pos (ctx@Ctx {cname, tau}) = do
         g <- getST
         -- ctx <- TC.reducedCtx ctx
         E.logmsg TRACEG (U.tauPos tau) (text (nicerctx [ctx] g))
         if make then makeCtx else findCtx
     where
         tauflat = tau.flat
         tcon  = head tauflat {- case head tauflat of
             TFun _ _ -> TCon {pos = Position.null, name = TName pPreludeBase "->"}  -- functions
             con      -> con -}
             
         -- targs = tail tauflat
         make | TCon {name} <- tcon = true
              | otherwise = false
 
         findCtx | Meta tv <- tau, tv.isFlexi = do
                         g <- getST
                         E.fatal pos (text ("unknwon context: " ++ nice cname g ++ " " ++ nice tau g))
                         stio (JAtom "null")
                 | otherwise = do
             g <- getST
             let
                 ctxsnms = zip (envCtxs g) ctxNames
                 implies = impliesG g
             E.logmsg TRACEG pos (text ("findCtx: looking for  " ++ nice cname g ++ " " ++ nice tau g))
             E.logmsg TRACEG pos (text ("findCtx: we have  " ++ nicectx (envCtxs g) g))
             let ok = [ name | (ctx1, name) <- ctxsnms, ctx1 `implies` ctx]
             E.logmsg TRACEG pos (text ("findCtx: ok= " ++ show ok))
             if (null ok)
                 then do 
                    E.error pos (text ("FATAL: Cant find context for " 
                            ++ nice cname g ++ " " ++ nice tau g))
                    E.error pos (text ("This is a compiler error. Sorry."))
                    stio (JAtom "UNKNOWN_CONTEXT")
                 else stio ((JAtom • head) ok)
         makeCtx  = do
             csym <- U.findC cname
             case tcon of
                 TCon {name} -> case filter ((name ==) • fst) csym.insts of
                     (_,iname):_ -> do
                         inst <- U.findI iname
                         g <- getST
                         let crho = RhoTau [] tau
                             csig = ForAll [] crho
                         E.logmsg TRACEG pos (text ("makeCtx: unify " ++ nice inst.typ g ++ "  with  "
                                 ++ nice csig g))
 
                         let tree = U.unifySigma g inst.typ csig
                             rho  = U.substRho tree inst.typ.rho
                         -- rhojt <- rhoJT rho
                         E.logmsg TRACEG pos (text ("makeCtx substituted: " ++ nice rho g))
                         let subctx = map (TC.reducedCtx g) rho.context
                         args <- mapSt (resolveConstraint pos) subctx
                         let jiname = U.javaName g inst.name
                             -- jrho   = rhoJT g rho
                             -- jitargs0 = [ RhoTau [] t
                             --                 | v <- inst.typ.bound, t <- (tree.lookupS v).toList]
                         -- jitjts     <- mapSt rhoJT jitargs
                         let jit    = Ref jiname []              -- jitjts
                             jex    = if null args
                                 then JStMem (memberOf jiname "it") [] 
                                 else JNew jit args
                         E.logmsg TRACEG pos (text ("makeCtx: " ++ showJex jex))
                         stio jex
                     [] -> do
                         g <- getST
                         E.fatal pos (text ("makeCtx: instance " ++ nice cname g ++ " " ++ nice tau g ++ " not found."))
                 other -> do
                     g <- getST
                     E.fatal pos (text ("makeCtx: head is " ++ nice other g))
 
instSymDirect :: Position -> Symbol -> Sigma -> StG (Binding)
instSymDirect pos sym sigma = do
    g <- getST
    E.logmsg TRACEG pos (text ("instSymDirect: "
                             ++ nice sym g ++ "::" ++ nice sym.typ g
                             ++ " at " ++ nice sigma g))
 
    let inst = U.sigmaInst g sym.typ sigma
        -- gargs = mapSt (tauJT g) inst
    
    E.logmsg TRACEG pos (text ("instSym: gargs = " ++ show (map (flip nice g) inst)))
    
    let -- jt    = sigmaJT g sigma
        str | Local {} <- sym.name, null sym.typ.bound = sym.typ.rho.{context = []}
            | otherwise = sym.typ.rho
        model = newBind g sigma (JAtom "instSymDirect")
        strho = U.substRho (U.unifySigma g sym.typ sigma) str
    E.logmsg TRACEG pos (text ("instSym: strho = " ++ nice strho g))
    let contexts = map  (TC.reducedCtx g)  strho.context
    ctxs     <- mapSt (resolveConstraint pos) contexts
 
    case sym of
        SymD {name=MName tynm _, flds} | null ctxs = do
            symt <- U.findT tynm
            if symt.enum
                then stio model.{jex = (JX.static (workerMethod g sym))}
                else if symt.newt
                    then do
                        sym <- U.findV (VName pPreludeBase "id")
                        instSymDirect pos sym sigma
                    else stio model.{jex = JX.static (workerMethod g sym)}
        SymV {name = Local {}, expr = Just _} = E.fatal sym.pos (text ("instSymDirect: " ++ nicer sym g))
        SymV {name, depth, rkind}
            | null ctxs = do
                let wm   = workerMethod g sym
                stio model.{jex = JX.static wm}
            | otherwise = do
                let instx = (JX.invoke ctxs • JX.static)
                                  (workerMethod g sym)
                stio model.{jex = instx}
        other -> E.fatal pos (text ("Can't instSymDirect " ++ nice sym g))
-- 
{--
    Instantiate a pattern bound symbol at a given type.
    This is interesting only for polymorphic functions that have a @forall@
    type and constraints, like
    
    > f :: forall e.Num e => [e] -> [e] @@ Num a => [a] -> [a]

    Here, we need to apply the 'Num' constraint to @f@
    -}
instPatternBound :: Position -> Binding -> Sigma -> StG Binding
instPatternBound pos bindns sigma = do
    g <- getST
    E.logmsg TRACEG pos (text ("instPatternBound: "
                             ++ show bindns 
                             ++ " @@ " ++ nice sigma g))
    let bind  = strictBind bindns   -- make sure we don't hit a Lazy<Lambda>
    let inst  = U.sigmaInst g bind.ftype sigma
        strho = U.substRho (U.unifySigma g bind.ftype sigma) bind.ftype.rho
    E.logmsg TRACEG pos (text ("instPatternBound: gargs = " ++ show (map (flip nice g) inst)))
    E.logmsg TRACEG pos (text ("instPatternBound: strho = " ++ nice strho g))
    let contexts = map  (TC.reducedCtx  g) strho.context
    ctxs     <- mapSt (resolveConstraint pos) contexts
    
    let result = fold app bind ctxs
        app (b::Binding) x = b.{jex <- JX.invoke [x] . JX.xmem "apply", jtype = Applicable}

    return (adapt result.{ftype <- Sigma.{rho <- Rho.{context=[]}},
                   stype =  nice strho.{context=[]} g } bind.jtype)

{--
  * instantiate a symbol at a given type
  -}
instSym :: Position -> Symbol -> Sigma -> StG Binding
instSym pos sym sigma = do
    g <- getST
    E.logmsg TRACEG pos (text ("instSym: "
                             ++ nice sym g ++ "::" ++ nice sym.typ g
                             ++ " @@ " ++ nice sigma g))
 
    let inst  = U.sigmaInst g sym.typ sigma
        
 
 
    -- let gargs = map (tauJT g) inst
    E.logmsg TRACEG pos (text ("instSym: gargs = " ++ show (map (flip nice g) inst)))
    let rstate = if sym.{rkind?} then sym.rkind else RState.singleton RValue
    let wjt    = returnType rstate (sigmaJT g sym.typ)
 
    let str | Local {} <- sym.name, null sym.typ.bound = sym.typ.rho.{context = []}
            | otherwise = sym.typ.rho
        strho = U.substRho (U.unifySigma g sym.typ sigma) str
        model  = newBind g (ForAll [] strho.{context=[]}) (JAtom "instSym")
    E.logmsg TRACEG pos (text ("instSym: strho = " ++ nice strho g))
    let contexts = map (TC.reducedCtx g)  strho.context
    ctxs     <- mapSt (resolveConstraint pos) contexts
 
    -- let (_, ss) = U.returnType sym.typ.rho
 
    case sym of
         SymD {name=MName tynm _, flds} | null ctxs = do
             let mkOrEnum = JX.static (workerMethod g sym)
             symt <- U.findT tynm
             if symt.enum
                 then stio model.{jtype = jtEnum, jex = mkOrEnum}
                 else if symt.newt
                     then do
                         sym <- U.findV (VName pPreludeBase "id")
                         instSym pos sym sigma
                     else if length flds == 0
                             then do
                                 let jx = {- JX.invoke [] -} mkOrEnum
                                     bind = model.{jtype=wjt, jex = jx}
                                 stio bind
                             else reqLam sym 
         SymV {name = MName clas m, depth, rkind} 
            | Just (SymC {tau}) <- g.findit clas = do
                 g <- getST
                 let inst   = JInvoke get (tail ctxs)
                     get    = JX.jexmem  (head ctxs) (latinF ++ mangled m)
                     mode   = if depth > 0
                                 then strict         -- function
                                 else lazy           -- by def in abstractFun
                     bind   = model.{jtype = mode wjt, jex = inst}
                 E.logmsg TRACEG pos (text ("instSym: " ++ show bind))                        
                 stio bind
         SymV {name = Local {}, expr = Just _} = E.fatal sym.pos (text ("instSym: " ++ nicer sym g))
         SymV {depth = 0, nativ = Just item} 
            | not (wrapped g sym),
              niKind item == NIStatic = do
                    let bind = nativeCall g sym []
                    return model.{jex = bind.jex, jtype = wjt} 
         SymV {name, depth = 0, rkind} -> do
                 let
                     -- mode = jtRmode wjt
                     item = JX.static (workerMethod g sym)
                     func | null ctxs = item
                          | otherwise = JX.invoke ctxs item
                     bind = model.{jex = func, jtype = wjt}
                 stio bind
         SymV {name, depth, rkind} = do
             bind <- reqLam sym
             if null ctxs then return bind
                 else return bind.{ftype = model.ftype, jex <- JX.invoke ctxs}
             -- | Just wc <- wrapperClass g sym = do
             --     let instx = (JX.invoke ctxs • JX.static) (wrapperInstance g sym)
             --     stio (Bind RBoxed sigma jt instx)
             -- | null ctxs = reqLam sym -- do
                 -- let wm   = wrapperInstance g sym
                 -- stio (Bind RBoxed sigma jt (JX.static wm))
         other -> E.fatal pos (text ("Can't instSym " ++ nice sym g))
 
 
apply :: Position -> Binding -> Binding -> StG Binding
apply pos x b = do
    g <- getST
    E.logmsg TRACEG pos
         (text("apply: " ++ show x ++ "  to:  " ++ show b))
    stio x.{jtype=Applicable, 
                jex=JInvoke (JX.jexmem x.jex "apply") [b.jex]}

--- genExpression returnexpression f expr binds
--- Generate java code for expression.
--- The target java type is determined by @expr@ and modified with @f@ 
genExpression :: Bool -> (JType -> JType) -> Expr -> TreeMap Symbol Binding -> StG Binding
genExpression ret stri x binds = do
    g <- getST
    let nt = sigmaJT g (unJust x.typ) 
    genExpr ret (stri nt) x binds

{--
    Before we proceed to generating simple expressions with 'genSimple',
    we have to check if there appears an unknown constraint with rigid meta type variables
    in the type, like for example: 
    
    > map (Num.* (Num.fromInt 2))  ::  Num t3244#e => [t3244#e] -> [t3244#e]
    
    This signals that the application @map (2*)@ gets passed to a higher ranked
    function who expects a function of type
    
    > forall e.Num e => [e] -> [e]
    
    The code that must be generated for this should look like:
    
    > new Lambda1() {
    >     public Lazy eval(Object num) {
    >         return work((CNum) num));
    >     }
    >     public T work (CNum ctx$n) {
    >       return [[genExpr true (strict JType) expr]] 
    >     }
    > }
    
    Note that we will hit the same expression inside the @work@ method, but since we pretend
    that we are compiling a symbol with  constraint @Num t3244#@, it will find it and 
    use it in instantiating @Num.*@ and @Num.fromInt@ later.
    
-}
genExpr :: Bool -> JType -> Expr -> TreeMap Symbol Binding -> StG Binding        
genExpr rflag rjtype expr binds | Just sigma <- expr.typ = do
        g     <- getST
        let ectxs = envCtxs g
            -- ctxTvs ctx = fst ((TC.ctxTvs ctx).run g)
            tctxs = filter  rigidContext sigma.rho.context
            rigidContext :: Context -> Bool
            rigidContext = (any (not . MetaTv.isFlexi) . TC.ctxTvs g)
        case tctxs of
            (_:_) | null [ ctx | ctx <- ectxs, tctx <- tctxs, impliesG g ctx tctx ] = do
                case expr of
                    Vbl{name = Local{}} |
                        Just sym  <- g.findit expr.name,
                        Just bind <- binds.lookup sym,
                        Nothing <- sym.expr,              -- pattern bound
                        not bind.ftype.bound.null,        -- forall a. ....
                        -- make sure the contexts are in the right order
                        -- we can't pass forall a b. (Num a, Num b) =>
                        -- when (Num b, Num a) is expected
                        uni <- U.substRho (U.unifySigma g bind.ftype sigma) bind.ftype.rho,
                        and (zipWith TC.sameCtx uni.context sigma.rho.context)
                            = do
                                E.logmsg TRACEG (getpos expr) (text(
                                    "genExpr: passing on "
                                    ++ nice expr g
                                    ++ " :: " ++ nice bind.ftype g
                                    ++ " @@ " ++ nice sigma g
                                    ))
                                return (adapt bind rjtype)             -- just pass on function 
                    _       =  wrapHigher tctxs ectxs sigma
            _ -> genSimple rflag rjtype expr binds
    where
        -- wrap expressions used as arguments for polymorphic thngs in 
        -- higher rank functions.
        wrapHigher :: [Context] -> [Context] -> Sigma -> StG Binding
        wrapHigher tctxs ectxs sigma = do
            g <- getST
            let depth    = length tctxs
                ctxNames = take depth (drop (length ectxs) GenJava7.ctxNames)
                ctxTypes = [ Ref{jname=U.javaName g cname, typeargs=[]} |
                                Ctx{cname} <- tctxs ]
                ctxexs   = zipWith JCast ctxTypes (map JAtom ctxNames)
                workarg jty name = (attrFinal, TY.sigInt, jty, name) 
                jtype    = jtFunc depth eval.jtype
                eval     = JMethod{attr=attrs [JPublic, JFinal], gargs=[], jtype=lazy rjtype, 
                                    name = "eval", 
                                    args = evalArgDef attrFinal (repeat sigma) ctxNames, 
                                    body = JBlock [
                                        JReturn (JInvoke (JAtom "work") ctxexs)
                            ]}
                faketype = ForAll [("ranks", KType)] (RhoFun{context=tctxs, sigma=TY.sigInt, rho=TY.rhoInt})
                fakesym  = (U.patLocal (getpos expr) 0 "\\rankN").{depth = 0, typ = faketype}
            E.logmsg TRACEG (getpos expr) (text("genExpr: wrapping " 
                ++ nice expr g
                ++ " :: " ++ nice sigma g
                ++ " @@ " ++ nice faketype g))
            E.logmsg TRACEG (getpos expr) (text("genExpr: in environment " 
                ++ nice faketype.rho.{context = ectxs} g))
            body <- compiling fakesym (genReturn (strict rjtype) expr binds)
            let newclass = JNewClass jtype  []  decls
                decls    = unCommentG g [eval, work]
                work     = JMethod{attr=attrFinal, gargs=[], jtype=strict rjtype, 
                                    name = "work", 
                                    args = zipWith workarg ctxTypes ctxNames, 
                                    body = JBlock body} 
            return (newBind g faketype newclass) 
genExpr rflag rjtype expr binds = genSimple rflag rjtype expr binds      

---   wrap the code of this binding in
---   > new Delayed() { public X eval() { return ...; }}
genDelayed :: Binding -> Binding
genDelayed bind = bind.{jtype <- lazy, jex = jx}
        -- g <- getST
      where jx = JNewClass{jt = jtDelayed, args=[], 
                    decls=[eval]}
            eval = JMethod{attr=GU.attrs[JFinal, JPublic], 
                       gargs=[], 
                       jtype=autoboxed bind.jtype, 
                       name = "eval", 
                       args = [], 
                       body = JBlock [JReturn bind.jex]}
         
 
   
{--
  * [usage] @genSimple rflag rtype expression binds@
  * [return] a binding that computes the simple frege expression at the desired 'JType'
  
  * If the @rflag@ is true, this signals a return expression.
  
  * Special handling occurs for lazy applications in return expressions: The arguments
  * of that tailcall are computed according to the strictness information of the
  * called function instead of all lazy. This is an optimization appropriate for
  * tail calls.
  -}
genSimple :: Bool -> JType -> Expr -> TreeMap Symbol Binding -> StG Binding
genSimple _ rm (Vbl {pos, name, typ = Just sigma}) binds
     | Local{} <- name = do
        g <- getST
        sym <- U.findV name
        E.logmsg TRACEG pos (text ("genSimple Vbl: " ++ nice sym g 
            ++ " :: " ++ nice sym.typ g
            ++ " @@ " ++ nice sigma g))
        case binds.lookup sym of
             Just b 
                | Nothing <- sym.expr,           -- pattern bound
                  not b.ftype.bound.null,        -- forall a. ....
                  not b.ftype.rho.context.null   -- forall a.C a => 
                            = instPatternBound pos b sigma
                | otherwise = do
                    E.logmsg TRACEG pos (text ("genSimple adapt  " ++
                        nice sym g ++ " from " ++ show b.jtype 
                        ++ "  to  " ++ show rm))
                    stio (adapt b rm)
             Nothing -> do
                 g <- getST
                 E.error pos (msgdoc ("genSimple: local " ++ nice sym g ++ " not bound"))
                 -- let sjt = sigmaJT g sigma
                 stio (newBind g sym.typ (JAtom ("UNBOUND." ++ name.base)))
     | otherwise = do
        g <- getST
        sym <- U.findV name
        bind <- instSym pos sym sigma
        let mbind = adapt bind rm
        -- E.logmsg TRACEG pos (msgdoc ("genSimple: got=" 
        --     ++ show bind
        --     ++ ", mode=" ++ show rm
        --     ++ ", return=" ++ show mbind)) 
        stio mbind
 
genSimple rflg rm (app@App a b (Just sigma)) binds = do
        g <- getST
        E.logmsg TRACEG pos (text ("genApp:  " ++ nice app g 
            ++ "  ::  " ++ nice sigma g
            ++ "  @@  " ++ show rm)) 
        genApp fun args
    where
        flat  = map fst (flatx app)
        fun   = head flat
        args  = tail flat
        pos = getpos app
        anys = repeat (Lazy Something)
        {-
            mode/ret     call          bad-tail?
            s/-          direct         warn
            l/s          apply/delayed  delayed
            l/l          apply/delayed  delayed
        -}
        isLazy :: JType -> Bool
        isLazy rm = not (isStrictJT rm) && (not rflg)
        {-
            checks if this is a tail call and the function is not
            tail safe.
        -}
        badTail SymV{rkind} = rflg && not (RSafeTC BitSet.`member` rkind)
        badTail _ = false
        lazyFun false jt  = jt
        lazyFun true  jt  = lazy jt
        genArgEx arm aex = genExpr false arm aex binds
        remaining !call rargs 
            | null rargs = do
                    g <- getST
                    E.logmsg TRACEG pos (text("resApp:  " 
                        ++ nice fun g
                        ++ " is " ++ show call.jtype
                        ++ " @@ " ++ show rm)) 
                    stio (adapt call rm)
            | otherwise  = do
                    g <- getST
                    rbinds <- sequence (zipWith genArgEx anys rargs)
                    r <- foldSt (apply pos) (call `adapt` Applicable) rbinds
                    stio (coerce g rm r.{ftype=sigma})
        coerce :: Global -> JType -> Binding -> Binding
        coerce g target  bind = adapt  bind.{stype = nicer bind.ftype g} target
        
        ari (sym@SymV {nativ=Just _}) = U.arity sym
        ari sym                       = sym.depth
        
        -- true, when at least one arg is a full application
        -- of a known function or constructor 
        appArg g args = any prop args where
                prop ex
                    | Ifte{}    <- ex = true
                    | App{}     <- ex,
                      flat      <- map fst (flatx ex),
                      Vbl{name} <- head flat,
                      Just sym  <- g.findit name 
                    = case sym of
                        SymV{} -> let a = ari sym in a > 0 && length flat > a  
                        SymD{} -> any ConField.strict sym.flds && length flat > length sym.flds
                        _      -> false
                prop _       = false
                    
        genApp (con@Con {pos, name = cname, typ = Just csigma}) args = do
            g <- getST
            sym <- U.findD cname
            si <- symInfo sym
            let a = length sym.flds
                -- asigs = map ConField.typ sym.flds
            if length args < a
                then genAnon con args          -- partial application
                else do
                    symt <- U.findT sym.name.tynm
                    if symt.product && symt.newt
                        then do
                            genExpr rflg rm (head args) binds
                            -- b <- genExpr rflg rm (head args) binds
                            -- stio (coerce g rm b.{ftype=sigma})
                        else do
                            let 
                                !struct = any (ConField.strict) sym.flds
                                !sjt    = sigmaJT g sigma
                                !aargs  = take a args
                                !rargs  = drop a args
                                dolazy  = isLazy rm
                                !ajts   = map (lazyFun dolazy) si.argJTs
                                sargs   = map snd . filter fst . zip (map ConField.strict sym.flds) $ aargs
                                                        
                            if struct && dolazy && appArg g sargs
                            then
                                -- we are calling a constructor Foo lazily that has 
                                -- strict fields, and in one of the fields there is
                                -- an application of bar.
                                -- Instead of
                                --   Foo.apply(bar.apply(a))
                                -- we generate
                                --   new Delayed () { return Foo(bar(a)); }
                                genSimple false (strict rm) app binds >>= return . genDelayed 
                            -- if there are any strict fields in the constructed value
                            -- and we need to be lazy, we must use the
                            -- conf.apply(...) form to be able to pass the arguments
                            -- lazily, except if the arguments are such that they can be
                            -- passed to the constructor.
                            -- If there are no strict fields, the arguments are demanded 
                            -- all lazy anyways, hence we can use the direct form, no matter
                            -- if it is required lazy or not. 
                            else do
                                abinds <- sequence (zipWith genArgEx ajts aargs)
                                 
                                if struct && dolazy 
                                    -- true if any binding would need conversion
                                    && not (and (zipWith 
                                                isA (map Binding.jtype abinds) 
                                                si.argJTs)) 
                                then do
                                    dbind <- instSym pos sym csigma
                                    let jx = JX.xmem "apply" dbind.jex
                                        call = (newBind g sigma 
                                            (JInvoke jx (map Binding.jex abinds))).{jtype = lazy sjt}
                                    remaining call rargs
                                else do
                                    dbind <- instSymDirect pos sym csigma
                                    let jx = dbind.jex
                                        call = newBind g sigma 
                                            (JInvoke jx (map Binding.jex abinds))
                                    remaining call rargs
 
        genApp (vbl@Vbl {pos, name, typ = Just vsigma}) args = do
            g     <- getST
            sym   <- U.findV name
            let d = ari sym
            if d < 1 || d > length args
                then genAnon vbl args
                else case U.isClassMember sym g of
                    Just (SymC {sid}) = do
                            -- when (U.isOn g.options.flags OPTIMIZE && d > 0 && !isLazy) do
                            --     U.hint pos (text ("using " ++ nicer sym g
                            --         ++ "  strictly."))
                            genClassMember sym vsigma args d
                    noclassmember -> case sym.nativ of
                        Just _    -> do
                                cenum <- isConstructorEnum sym vsigma
                                if cenum && length args == 1
                                     then genExpr rflg rm (head args) binds
                                     else genNative sym 
                        nonnative -> -- if isLazy && rflg && (RSafeTC `member` sym.rkind)
                                       -- then genExpr rflg (strict rm)  app binds
                                       -- else genDirect sym
                                    genDirect sym
          where
            -- when we have (constructor Gt), for example.
            isConstructorEnum (SymV {name=VName pp1 "constructor"})
                (ForAll [] (RhoFun []
                    (ForAll [] (RhoTau [] (TCon {name})))
                    (RhoTau [] (TCon {name=TName pp2 "Int"}))
                )) | pp1 == pPreludeBase, pp2 == pPreludeBase = do
                    symt <- U.findT name
                    stio symt.enum
            isConstructorEnum _ _ = stio false
            -- tailcall   = rflg && isLazy
            
            -- depth is guaranteed to be <= length args
            genClassMember sym vsigma args d = do
                g    <- getST
                si   <- symInfo sym
                bind <- instSym pos sym vsigma
                
                let aargs = take d args
                    rargs = drop d args
                
                -- prepare the arguments, they must be lazy
                abinds <- sequence (zipWith genArgEx anys aargs)
                -- si     <- symInfo sym
                
                if isStrictJT rm
                then do
                    let cargs = map Binding.jex (reverse abinds)
                        call  = Bind{stype=nicer sigma g, ftype=sigma, 
                                    jtype = lazy si.returnJT, 
                                    jex = (JX.invoke cargs . JX.xmem "eval") bind.jex}
                    remaining call rargs
                else do
                    let cargs = map Binding.jex abinds
                        call  = Bind{stype=nicer sigma g, ftype=sigma, 
                                    jtype = lazy si.returnJT,
                                    jex = (JX.invoke cargs . JX.xmem "apply") bind.jex}
                    remaining call rargs
                
                    
            
            genNative sym = do
                g  <- getST
                -- si <- symInfo sym
                let !acall  = isLazy rm 
                    !wcall  = not acall && (wrappedOnly g sym || not (null sym.typ.bound))
                    atau    = fst (U.returnType (Symbol.typ sym).rho)
                    !depth      = ari sym
                    !aargs      = take depth args
                    !rargs      = drop depth args
                
                if acall then genSimple false (strict rm) app binds >>= return . genDelayed
                else if wcall then genDirect sym
                else do
                    -- g <- getST
                    si <- symInfo sym
                    abinds <- sequence (zipWith genArgEx si.argJTs aargs)
                    let call 
                            | wrapped g sym = case wrapCode g JEx atau sym abinds of
                                    (JEx ex:_) -> Bind (nicer sigma g) sigma si.returnJT ex
                                    _ -> error "unexpected wrapCode result"
                            | otherwise = nativeCall g sym abinds
                    remaining call rargs
                    
            genDirect :: Symbol -> StG Binding
            genDirect sym = do
                g <- getST
                si <- symInfo sym
                --          lazy type   returnflag      safe TC     
                --          false       false           false       strict
                --          false       false           true        strict
                --          false       true            false       MUST NOT HAPPEN*)
                --          false       true            true        strict
                --          true        false           false       lazy
                --          true        false           true        lazy
                --          true        true            false       lazy
                --          true        true            true        strict
                --
                -- *) Because in that case, we would use apply(...) to get a Delayed
                -- which would have to be forced immediately, which makes no sense
                let straight = not (isLazy rm)
                when (isStrictJT rm && badTail sym
                        -- do not warn for CAFs
                        && all ((>0) . Symbol.depth) g.genEnv) do
                    E.hint pos (text ("deep recursion possible due to application of " 
                        ++ nicer sym g ++ " " ++ show sym.rkind
                        ++ " in strict context."))
                -- find the args
                -- let sargs = map snd . filter fst . zip (map isStrictJT si.argJTs) $ args
                -- do we have an application in some arg? 
                let delayed = (not straight && appArg g args) || 
                              (rflg && badTail sym 
                                    && not (isStrictJT rm))   
                -- are we lazy, so that we would be forced to compile
                --     take (i-1) xs
                -- as take.apply(minus.apply(i,1), xs)
                -- In that case we better do
                --
                --    new Delayed() {
                --        public Object eval() {
                --            return take(i-1, xs);
                --        }
                --    }
                case binds.lookup sym of
                    Just (b@Bind{jtype=Lambda})
                        | delayed = genStraight false  sym si b.{jex <- JX.xmem (workNameSI si)} >>= return . genDelayed
                        | not straight = genStraight true   sym si b.{jex <- JX.xmem "apply"}
                        | otherwise    = genStraight false  sym si b.{jex <- JX.xmem (workNameSI si)}
                    Just b -> genAnon vbl args  -- lambda bound function
                    Nothing
                        | delayed = instSymDirect pos sym vsigma >>= genStraight false sym si >>= return . genDelayed
                        | not straight = do
                            bcall <- instSym pos sym vsigma
                            genStraight true sym si bcall.{jex <- JX.xmem "apply"}
                        | otherwise  = do
                            bcall <- instSymDirect pos sym vsigma
                            genStraight false sym si bcall
            genStraight :: Bool -> Symbol -> SymInfo -> Binding -> StG Binding
            genStraight callLazy sym si vbind = do
                g <- getST
--                     E.logmsg TRACEG sym.pos (text("genStraight: " ++ nice sym g ++ " as " ++ nice vbind g))
--                     E.logmsg TRACEG sym.pos (anno vbind.jex)

                let jx = vbind.jex
                    (ctxs, static) = case jx of         -- be sure to collect context args
                        JInvoke x xs  -> (xs, x)
                        x             -> ([], x)
                    aew = case static of
                        JExMem {name} -> Just name      -- name of worker method, may be 
                                                        -- "apply", "eval" or "work"
                        _             -> Nothing
                    !rev = if aew == Just "eval" then reverse else id
                    lazyresult = maybe false (=="apply") aew && !callLazy  
                    ajts 
                        | Just s <- aew,  s `elem` ["eval", "apply"] = anys
                        | otherwise = map (lazyFun callLazy) si.argJTs
                    !depth      = ari sym
                    !aargs      = take depth args
                    !rargs      = drop depth args

                abinds <- sequence (zipWith genArgEx ajts aargs)
                let call = Bind (nicer sigma g) sigma 
                            (if lazyresult then lazy si.returnJT else si.returnJT) 
                            (JInvoke static (ctxs ++ map Binding.jex (rev abinds)))
                remaining call rargs
-- 
-- 
        genApp fun args = genAnon fun args
-- 
        genAnon fun args = do
            g      <-   getST
            fbind  <-   genExpr false Lambda fun binds
            abinds <-   sequence (zipWith genArgEx anys args) -- mapSt (flip (genExpression false lazy) binds) args
            appl   <-   foldSt (apply pos) fbind abinds
            let raw    = appl.{ftype=sigma}
            stio (coerce g rm raw)

genSimple _ rm (Con {pos, name, typ = Just sigma}) binds = do
    g    <- getST
    sym  <- U.findD name
    bind <- instSym pos sym sigma
    stio (adapt bind rm)
 
genSimple _ _ (Lit {kind, value, typ = Just sigma}) binds
    | kind != LRegex && kind != LBig = do
            g <- getST
            -- let jt = sigmaJT g sigma
            let v
                    | kind `elem` [LInt, LLong, LDouble, LFloat] = value.replaceAll ´_´ ""
                    | otherwise = value
            stio (newBind g sigma  (JAtom v))

genSimple _ rm (x@Lit {kind,value,typ=Just sigma}) binds = do
        jname <- findConst x
        g <- getST
        -- let jt = sigmaJT g sigma
        let bind = newBind g sigma (JStMem jname [])  
        stio bind


genSimple rflg target (ifte@Ifte c t e (Just sigma)) binds 
    | not (isStrictJT target) = 
        genSimple rflg (strict target) ifte binds >>= return . genDelayed 
 
genSimple rflg target (ifte@Ifte c t e (Just sigma)) binds = do
     g <- getST
     cbind <- genExpr false Nativ{typ="boolean", typeargs=[]} c binds
     tbind <- genExpr rflg target      t binds
     ebind <- genExpr rflg target      e binds
     stio (adapt (newBind g sigma  
                            (JQC cbind.jex tbind.jex ebind.jex)) target)
 
genSimple _ rm (lam@Lam{}) binds = do
    g <- getST
    bind <- lambdaEx lam binds
    stio (adapt bind rm)
 
genSimple rflg rm ex binds = do
    g <- getST
    let ft = unJust (Expr.typ ex)
    E.error (getpos ex) (text ("Cannot genSimple: " ++ nicer ex g ++ " :: " ++ nicer ft g))
    return (newBind g TY.sigBool (JAtom "cannotgenexpression"))
